
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/guatom999/TicketShop-Movie/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/guatom999/TicketShop-Movie/database/database.go (0.0%)</option>
				
				<option value="file2">github.com/guatom999/TicketShop-Movie/database/migrate/booking.go (0.0%)</option>
				
				<option value="file3">github.com/guatom999/TicketShop-Movie/database/migrate/customer.go (0.0%)</option>
				
				<option value="file4">github.com/guatom999/TicketShop-Movie/database/migrate/inventory.go (0.0%)</option>
				
				<option value="file5">github.com/guatom999/TicketShop-Movie/database/migrate/movie.go (0.0%)</option>
				
				<option value="file6">github.com/guatom999/TicketShop-Movie/database/migrate/payment.go (0.0%)</option>
				
				<option value="file7">github.com/guatom999/TicketShop-Movie/database/migrate/ticket.go (0.0%)</option>
				
				<option value="file8">github.com/guatom999/TicketShop-Movie/database/redisConn/redis.go (0.0%)</option>
				
				<option value="file9">github.com/guatom999/TicketShop-Movie/database/script/migration.go (0.0%)</option>
				
				<option value="file10">github.com/guatom999/TicketShop-Movie/main.go (0.0%)</option>
				
				<option value="file11">github.com/guatom999/TicketShop-Movie/modules/auth/authHandlers/authHandler.go (0.0%)</option>
				
				<option value="file12">github.com/guatom999/TicketShop-Movie/modules/auth/authRepositories/authRepository.go (0.0%)</option>
				
				<option value="file13">github.com/guatom999/TicketShop-Movie/modules/auth/authUseCases/authUseCase.go (0.0%)</option>
				
				<option value="file14">github.com/guatom999/TicketShop-Movie/modules/book/bookHandlers/bookHandler.go (0.0%)</option>
				
				<option value="file15">github.com/guatom999/TicketShop-Movie/modules/book/bookRepositories/bookRepository.go (0.0%)</option>
				
				<option value="file16">github.com/guatom999/TicketShop-Movie/modules/book/bookUseCases/bookUseCase.go (0.0%)</option>
				
				<option value="file17">github.com/guatom999/TicketShop-Movie/modules/customer/customerHandlers/customerHandler.go (0.0%)</option>
				
				<option value="file18">github.com/guatom999/TicketShop-Movie/modules/customer/customerRepositories/customerRepository.go (0.0%)</option>
				
				<option value="file19">github.com/guatom999/TicketShop-Movie/modules/customer/customerRepositories/customerRepositoryMock.go (0.0%)</option>
				
				<option value="file20">github.com/guatom999/TicketShop-Movie/modules/customer/customerUseCases/customerUsecase.go (0.0%)</option>
				
				<option value="file21">github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryHandlers/inventoryHandler.go (0.0%)</option>
				
				<option value="file22">github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryHandlers/inventoryQueue.go (0.0%)</option>
				
				<option value="file23">github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryRepositories/inventoryRepository.go (0.0%)</option>
				
				<option value="file24">github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryUseCases/inventoryUseCase.go (0.0%)</option>
				
				<option value="file25">github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareHandlers/middlewareHandler.go (0.0%)</option>
				
				<option value="file26">github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareRepositories/middlewareRepository.go (0.0%)</option>
				
				<option value="file27">github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareUseCases/middlewareUseCase.go (0.0%)</option>
				
				<option value="file28">github.com/guatom999/TicketShop-Movie/modules/movie/moviesHandlers/movieHandler.go (0.0%)</option>
				
				<option value="file29">github.com/guatom999/TicketShop-Movie/modules/movie/moviesHandlers/movieQueueHandler.go (0.0%)</option>
				
				<option value="file30">github.com/guatom999/TicketShop-Movie/modules/movie/moviesRepositories/movieRepository.go (0.0%)</option>
				
				<option value="file31">github.com/guatom999/TicketShop-Movie/modules/movie/moviesRepositories/movieRepositoryMock.go (0.0%)</option>
				
				<option value="file32">github.com/guatom999/TicketShop-Movie/modules/movie/moviesUseCases/movieUseCase.go (0.0%)</option>
				
				<option value="file33">github.com/guatom999/TicketShop-Movie/modules/payment/paymentHandlers/paymentHandler.go (0.0%)</option>
				
				<option value="file34">github.com/guatom999/TicketShop-Movie/modules/payment/paymentRepositories/paymentRepository.go (0.0%)</option>
				
				<option value="file35">github.com/guatom999/TicketShop-Movie/modules/payment/paymentUseCases/paymentUseCase.go (0.0%)</option>
				
				<option value="file36">github.com/guatom999/TicketShop-Movie/modules/ticket/ticketHandlers/ticketHandler.go (0.0%)</option>
				
				<option value="file37">github.com/guatom999/TicketShop-Movie/modules/ticket/ticketRepositories/ticketRepository.go (0.0%)</option>
				
				<option value="file38">github.com/guatom999/TicketShop-Movie/modules/ticket/ticketUseCases/ticketUseCase.go (0.0%)</option>
				
				<option value="file39">github.com/guatom999/TicketShop-Movie/pkg/file/file.go (0.0%)</option>
				
				<option value="file40">github.com/guatom999/TicketShop-Movie/pkg/jwtauth/jwtauth.go (0.0%)</option>
				
				<option value="file41">github.com/guatom999/TicketShop-Movie/pkg/opn/omise.go (0.0%)</option>
				
				<option value="file42">github.com/guatom999/TicketShop-Movie/pkg/queue/kafka.go (0.0%)</option>
				
				<option value="file43">github.com/guatom999/TicketShop-Movie/pkg/rest/req.go (0.0%)</option>
				
				<option value="file44">github.com/guatom999/TicketShop-Movie/server/booking.go (0.0%)</option>
				
				<option value="file45">github.com/guatom999/TicketShop-Movie/server/customer.go (0.0%)</option>
				
				<option value="file46">github.com/guatom999/TicketShop-Movie/server/echoServer.go (0.0%)</option>
				
				<option value="file47">github.com/guatom999/TicketShop-Movie/server/inventory.go (0.0%)</option>
				
				<option value="file48">github.com/guatom999/TicketShop-Movie/server/movie.go (0.0%)</option>
				
				<option value="file49">github.com/guatom999/TicketShop-Movie/server/payment.go (0.0%)</option>
				
				<option value="file50">github.com/guatom999/TicketShop-Movie/server/ticket.go (0.0%)</option>
				
				<option value="file51">github.com/guatom999/TicketShop-Movie/test/setup.go (100.0%)</option>
				
				<option value="file52">github.com/guatom999/TicketShop-Movie/test/test.go (0.0%)</option>
				
				<option value="file53">github.com/guatom999/TicketShop-Movie/utils/convert.go (0.0%)</option>
				
				<option value="file54">github.com/guatom999/TicketShop-Movie/utils/file.go (0.0%)</option>
				
				<option value="file55">github.com/guatom999/TicketShop-Movie/utils/genqrcode.go (0.0%)</option>
				
				<option value="file56">github.com/guatom999/TicketShop-Movie/utils/randString.go (0.0%)</option>
				
				<option value="file57">github.com/guatom999/TicketShop-Movie/utils/sendMail.go (0.0%)</option>
				
				<option value="file58">github.com/guatom999/TicketShop-Movie/utils/time.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "log"
        "path/filepath"

        "github.com/spf13/viper"
)

type (
        Config struct {
                App    App
                Db     Db
                AppUrl AppUrl
                Jwt    Jwt
                Kafka  Kafka
                Omise  Omise
                Gcp    Gcp
                Redis  Redis
                Mailer Mailer
        }

        App struct {
                Name string
                Port string
        }

        Db struct {
                Url string
        }
        AppUrl struct {
                CustomerUrl  string
                InventoryUrl string
                MovieUrl     string
                PaymentUrl   string
                TicketUrl    string
        }
        Jwt struct {
                AccessSecretKey  string
                RefreshSecretKey string
                ApiSecretKey     string
                AccessDuration   int64
                RefreshDuration  int64
        }

        Kafka struct {
                Url       string
                ApiKey    string
                SecretKey string
        }

        Omise struct {
                PublicKey string
                SecretKey string
        }

        Gcp struct {
                BucketName string
                FileLimit  int64
        }

        Redis struct {
                RedisUrl string
        }

        Mailer struct {
                MailerHost     string
                MailerPort     int
                MailerUserName string
                MailerPassword string
        }
)

func GetConfig(path string) Config <span class="cov0" title="0">{

        dir, file := filepath.Split(path)
        fmt.Println("dir and file is", dir, file)
        // fileName := strings.TrimPrefix(file, ".env.")

        viper.SetConfigName(file)
        viper.SetConfigType("env")
        viper.AddConfigPath(dir)
        viper.AutomaticEnv()

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("fatal error config file: %s", err.Error())
                panic(err)</span>
        }

        <span class="cov0" title="0">return Config{
                App: App{
                        Name: viper.GetString("APP_NAME"),
                        Port: viper.GetString("APP_PORT"),
                },
                Db: Db{
                        Url: viper.GetString("DB_URL"),
                },
                AppUrl: AppUrl{
                        CustomerUrl:  viper.GetString("TICKET_CUSTOMER_URL"),
                        InventoryUrl: viper.GetString("TICKET_INVENTORY_URL"),
                        MovieUrl:     viper.GetString("TICKET_MOVIE_URL"),
                        PaymentUrl:   viper.GetString("TICKET_PAYMENT_URL"),
                        TicketUrl:    viper.GetString("TICKET_TICKET_URL"),
                },
                Jwt: Jwt{
                        AccessSecretKey:  viper.GetString("JWT_ACCESS_SECRET_KEY"),
                        RefreshSecretKey: viper.GetString("JWT_REFRESH_SECRET_KEY"),
                        ApiSecretKey:     viper.GetString("JWT_API_SECRET_KEY"),
                        AccessDuration:   int64(viper.GetInt("JWT_ACCESS_DURATION")),
                        RefreshDuration:  int64(viper.GetInt("JWT_REFRESH_DURATION")),
                },
                Kafka: Kafka{
                        Url:       viper.GetString("KAFKA_URL"),
                        ApiKey:    viper.GetString("KAFKA_API_KEY"),
                        SecretKey: viper.GetString("KAFKA_SECRET_KEY"),
                },
                Omise: Omise{
                        PublicKey: viper.GetString("OMISE_PUBLIC_KEY"),
                        SecretKey: viper.GetString("OMISE_SECRET_KEY"),
                },
                Gcp: Gcp{
                        BucketName: viper.GetString("APP_GCP_BUCKET"),
                        FileLimit:  int64(viper.GetInt("APP_FILE_LIMIT")),
                },
                Redis: Redis{
                        RedisUrl: viper.GetString("REDIS_URL"),
                },
                Mailer: Mailer{
                        MailerHost:     viper.GetString("MAILER_HOST"),
                        MailerPort:     viper.GetInt("MAILER_PORT"),
                        MailerUserName: viper.GetString("MAILER_USERNAME"),
                        MailerPassword: viper.GetString("MAILER_PASSWORD"),
                },
        }</span>
}

func GetMigrateConfig(path string) Config <span class="cov0" title="0">{
        viper.SetConfigName(fmt.Sprintf(".env.%s", path))
        viper.SetConfigType("env")
        viper.AddConfigPath("../../env")
        viper.AutomaticEnv()

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("fatal error config file: %s", err.Error())
                panic(err)</span>
        }

        <span class="cov0" title="0">return Config{
                App: App{
                        Name: viper.GetString("APP_NAMe"),
                        Port: viper.GetString("APP_PORT"),
                },
                Db: Db{
                        Url: viper.GetString("DB_URL"),
                },
                Jwt: Jwt{
                        AccessSecretKey:  viper.GetString("JWT_ACCESS_SECRET_KEY"),
                        RefreshSecretKey: viper.GetString("JWT_REFRESH_SECRET_KEY"),
                        ApiSecretKey:     viper.GetString("JWT_API_SECRET_KEY"),
                        AccessDuration:   int64(viper.GetInt("JWT_ACCESS_DURATION")),
                        RefreshDuration:  int64(viper.GetInt("JWT_REFRESH_DURATION")),
                },
                Kafka: Kafka{
                        Url:       viper.GetString("KAFKA_URL"),
                        ApiKey:    viper.GetString("KAFKA_API_KEY"),
                        SecretKey: viper.GetString("KAFKA_SECRET_KEY"),
                },

                Omise: Omise{
                        PublicKey: viper.GetString("OMISE_PUBLIC_KEY"),
                        SecretKey: viper.GetString("OMISE_SECRET_KEY"),
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "context"
        "log"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.mongodb.org/mongo-driver/mongo/readpref"
)

func DbConn(pctx context.Context, cfg *config.Config) *mongo.Client <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, 10*time.Second)
        defer cancel()

        client, err := mongo.Connect(ctx, options.Client().ApplyURI(cfg.Db.Url))

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: Connect to database error : %v", err)
        }</span>

        <span class="cov0" title="0">if err = client.Ping(ctx, readpref.Primary()); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: Pinging to database error: %v", err)
        }</span>

        <span class="cov0" title="0">return client</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package migrate

import (
        "context"
        "log"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/database"
        "github.com/guatom999/TicketShop-Movie/modules/book"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
)

func BookingMigrate(pctx context.Context, cfg *config.Config) <span class="cov0" title="0">{

        db := database.DbConn(pctx, cfg).Database("booking_db")
        defer db.Client().Disconnect(pctx)

        col := db.Collection("booking_history")

        _, err := col.Indexes().CreateMany(pctx, []mongo.IndexModel{
                {Keys: bson.D{{"_id", 1}}},
                {Keys: bson.D{{"customer_id", 1}}},
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: CreateIndex Failed")
                panic(err)</span>
        }

        <span class="cov0" title="0">documents := func() []any </span><span class="cov0" title="0">{
                mockdatas := []*book.BookingHistory{
                        {
                                CustomerId: "customer0001",
                                MovieName:  "Lalaland",
                                Quantity:   1,
                                Price:      150,
                                BookingAt:  utils.GetLocaltime(),
                                Seat: []book.Seat{
                                        {Number: "A3"},
                                },
                                ShowTime: "15.30",
                        },
                        {
                                CustomerId: "customer0002",
                                MovieName:  "Lalaland",
                                Quantity:   1,
                                Price:      150,
                                BookingAt:  utils.GetLocaltime(),
                                Seat: []book.Seat{
                                        {Number: "A4"},
                                },
                                ShowTime: "15.30",
                        },
                }

                datas := make([]any, 0)

                for _, i := range mockdatas </span><span class="cov0" title="0">{
                        datas = append(datas, i)
                }</span>

                <span class="cov0" title="0">return datas</span>

        }()

        <span class="cov0" title="0">result, err := col.InsertMany(pctx, documents)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Insert BookingHistory failed:%s", err.Error())
                panic(err)</span>
        }

        <span class="cov0" title="0">col = db.Collection("booking_transaction")

        _, err = col.InsertOne(pctx, bson.D{})

        if err != nil </span><span class="cov0" title="0">{
                log.Println("insert booking transaction failed")
                panic(err)</span>
        }

        <span class="cov0" title="0">col = db.Collection("booking_payment_queue")

        _, err = col.InsertOne(pctx, bson.D{})

        if err != nil </span><span class="cov0" title="0">{
                log.Println("insert booking transaction failed")
                panic(err)</span>
        }

        <span class="cov0" title="0">log.Println("Migrate Booking History completed:", result)</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package migrate

import (
        "context"
        "log"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/database"
        "github.com/guatom999/TicketShop-Movie/modules/customer"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "golang.org/x/crypto/bcrypt"
)

func CustomerMigrate(pctx context.Context, cfg *config.Config) <span class="cov0" title="0">{
        db := database.DbConn(pctx, cfg).Database("customer_db")
        defer db.Client().Disconnect(pctx)

        col := db.Collection("customer")

        documents := func() []any </span><span class="cov0" title="0">{
                mocksDatas := []customer.Customer{
                        {
                                UserName: "customer1",
                                Email:    "test1234@hotmail.com",
                                Password: func() string </span><span class="cov0" title="0">{

                                        hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("test1234"), 10)

                                        return string(hashedPassword)
                                }</span>(),
                                Created_At: utils.GetLocaltime(),
                                Updated_At: utils.GetLocaltime(),
                        },
                }

                <span class="cov0" title="0">datas := make([]any, 0)

                for _, v := range mocksDatas </span><span class="cov0" title="0">{
                        datas = append(datas, v)

                }</span>

                <span class="cov0" title="0">return datas</span>
        }()

        <span class="cov0" title="0">result, err := col.InsertMany(pctx, documents)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Insert Customer failed:%s", err.Error())
                panic(err)</span>
        }

        <span class="cov0" title="0">col = db.Collection("customer_auth")

        indexs, _ := col.Indexes().CreateMany(pctx, []mongo.IndexModel{
                {Keys: bson.D{{"_id", 1}}},
                {Keys: bson.D{{"player_id", 1}}},
                {Keys: bson.D{{"refresh_token", 1}}},
        })

        for i, index := range indexs </span><span class="cov0" title="0">{
                log.Printf("Index %d is %s", i, index)
        }</span>

        <span class="cov0" title="0">log.Println("BookingHistoryMigrate Customer Db completed", result)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package migrate

import (
        "context"
        "fmt"
        "log"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/database"
        "github.com/guatom999/TicketShop-Movie/modules/inventory"
)

func InventoryMigrate(pctx context.Context, cfg *config.Config) <span class="cov0" title="0">{

        db := database.DbConn(pctx, cfg).Database("inventory_db")
        defer db.Client().Disconnect(pctx)

        col := db.Collection("ticket_inventory")

        documents := func() []any </span><span class="cov0" title="0">{
                mockDatas := []inventory.CustomerTicket{
                        {
                                CustomerId: "user0001",
                                // TicketId:   "Ticket0001",
                        },
                }

                data := make([]any, 0)

                for _, v := range mockDatas </span><span class="cov0" title="0">{
                        data = append(data, v)
                }</span>

                <span class="cov0" title="0">return data</span>

        }()

        <span class="cov0" title="0">if _, err := col.InsertMany(pctx, documents); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error inserting: Insert Inventory failed :%s", err.Error())
                panic(err)</span>
        }

        <span class="cov0" title="0">fmt.Println("Migrate Inventory successfully")</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package migrate

import (
        "context"
        "log"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/database"
        "github.com/guatom999/TicketShop-Movie/modules/movie"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
)

func MovieMigrate(pctx context.Context, cfg *config.Config) <span class="cov0" title="0">{

        db := database.DbConn(pctx, cfg).Database("movie_db")
        defer db.Client().Disconnect(pctx)

        col := db.Collection("movie")

        // set index
        _, err := col.Indexes().CreateMany(pctx, []mongo.IndexModel{
                {Keys: bson.D{{"_id", 1}}},
                {Keys: bson.D{{"title", 1}}},
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: CreateIndex Failed")
                panic(err)</span>
        }

        <span class="cov0" title="0">documents := func() []any </span><span class="cov0" title="0">{
                mockdatas := []*movie.Movie{
                        {
                                Title:           "Lalaland",
                                Description:     "Lorem Ipsum is simply dummy text of the printing and typesetting industry. ",
                                RunningTime:     "1 ชั่วโมง 30 นาที",
                                Price:           150,
                                ImageUrl:        "https://i5.walmartimages.com/seo/La-La-Land-Movie-Poster-Poster-Print-24-x-36_20f02811-01b4-4aea-9bb2-a79942bd2642_1.856c035d66f8fd216f6d933259bc3dfb.jpeg",
                                CreatedAt:       utils.GetLocaltime(),
                                UpdatedAt:       utils.GetLocaltime(),
                                Category:        "RomCom",
                                ReleaseAt:       utils.GetLocaltime(),
                                OutOfTheatersAt: utils.GetLocaltime().Add(time.Hour * 168),
                        },
                        {
                                Title:           "GI JOE",
                                Description:     "Lorem Ipsum is simply dummy text of the printing and typesetting industry. ",
                                RunningTime:     "1 ชั่วโมง 30 นาที",
                                Price:           150,
                                ImageUrl:        "https://m.media-amazon.com/images/M/MV5BMTQzMTU1NzQwNl5BMl5BanBnXkFtZTcwNDg4NzMzMw@@._V1_.jpg",
                                CreatedAt:       utils.GetLocaltime(),
                                UpdatedAt:       utils.GetLocaltime(),
                                ReleaseAt:       utils.GetLocaltime(),
                                Category:        "RomCom",
                                OutOfTheatersAt: utils.GetLocaltime().Add(time.Hour * 168),
                        },
                        {
                                Title:           "HarryPotter1",
                                Description:     "Lorem Ipsum is simply dummy text of the printing and typesetting industry. ",
                                RunningTime:     "1 ชั่วโมง 30 นาที",
                                Price:           150,
                                ImageUrl:        "https://lh3.googleusercontent.com/proxy/Hh8fT3IQBPFWFkHdvwDBig3USKUOCYXqvzcVWq1Rj_S3tm1k0NzUUlbrjjHyWjCylx6bHsvhOhGdQ_EfsRUDYlR86b1TJZZzjtcDAetDy-rsTdDKL5lIfcGyjeiW1b3OMbhRcmEEniv6EYBNhRJPZZggmy1QGJ_SYX-iHfg-K_knSf5H",
                                CreatedAt:       utils.GetLocaltime(),
                                UpdatedAt:       utils.GetLocaltime(),
                                ReleaseAt:       utils.GetLocaltime(),
                                Category:        "RomCom",
                                OutOfTheatersAt: utils.GetLocaltime().Add(time.Hour * 168),
                        },
                        {
                                Title:           "HarryPotter3",
                                Description:     "Lorem Ipsum is simply dummy text of the printing and typesetting industry. ",
                                RunningTime:     "1 ชั่วโมง 30 นาที",
                                Price:           150,
                                ImageUrl:        "https://lh3.googleusercontent.com/proxy/Hh8fT3IQBPFWFkHdvwDBig3USKUOCYXqvzcVWq1Rj_S3tm1k0NzUUlbrjjHyWjCylx6bHsvhOhGdQ_EfsRUDYlR86b1TJZZzjtcDAetDy-rsTdDKL5lIfcGyjeiW1b3OMbhRcmEEniv6EYBNhRJPZZggmy1QGJ_SYX-iHfg-K_knSf5H",
                                CreatedAt:       utils.GetLocaltime(),
                                UpdatedAt:       utils.GetLocaltime(),
                                ReleaseAt:       utils.GetLocaltime(),
                                Category:        "RomCom",
                                OutOfTheatersAt: utils.GetLocaltime().Add(time.Hour * 168),
                        },
                        {
                                Title:           "HarryPotter4",
                                Description:     "Lorem Ipsum is simply dummy text of the printing and typesetting industry. ",
                                RunningTime:     "1 ชั่วโมง 30 นาที",
                                Price:           150,
                                ImageUrl:        "https://lh3.googleusercontent.com/proxy/Hh8fT3IQBPFWFkHdvwDBig3USKUOCYXqvzcVWq1Rj_S3tm1k0NzUUlbrjjHyWjCylx6bHsvhOhGdQ_EfsRUDYlR86b1TJZZzjtcDAetDy-rsTdDKL5lIfcGyjeiW1b3OMbhRcmEEniv6EYBNhRJPZZggmy1QGJ_SYX-iHfg-K_knSf5H",
                                CreatedAt:       utils.GetLocaltime(),
                                UpdatedAt:       utils.GetLocaltime(),
                                ReleaseAt:       utils.GetLocaltime(),
                                Category:        "RomCom",
                                OutOfTheatersAt: utils.GetLocaltime().Add(time.Hour * 168),
                        },
                        {
                                Title:           "HarryPotter5",
                                Description:     "Lorem Ipsum is simply dummy text of the printing and typesetting industry. ",
                                RunningTime:     "1 ชั่วโมง 30 นาที",
                                Price:           150,
                                ImageUrl:        "https://lh3.googleusercontent.com/proxy/Hh8fT3IQBPFWFkHdvwDBig3USKUOCYXqvzcVWq1Rj_S3tm1k0NzUUlbrjjHyWjCylx6bHsvhOhGdQ_EfsRUDYlR86b1TJZZzjtcDAetDy-rsTdDKL5lIfcGyjeiW1b3OMbhRcmEEniv6EYBNhRJPZZggmy1QGJ_SYX-iHfg-K_knSf5H",
                                CreatedAt:       utils.GetLocaltime(),
                                UpdatedAt:       utils.GetLocaltime(),
                                ReleaseAt:       utils.GetLocaltime(),
                                Category:        "RomCom",
                                OutOfTheatersAt: utils.GetLocaltime().Add(time.Hour * 168),
                        },
                }

                docs := make([]any, 0)
                for _, i := range mockdatas </span><span class="cov0" title="0">{
                        docs = append(docs, i)
                }</span>
                <span class="cov0" title="0">return docs</span>
        }()

        <span class="cov0" title="0">results, err := col.InsertMany(pctx, documents)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">col = db.Collection("movie_available")

        _, err = col.Indexes().CreateMany(pctx, []mongo.IndexModel{
                {Keys: bson.D{{"movie_id", 1}}},
                {Keys: bson.D{{"title", 1}}},
        })

        documents = func() []any </span><span class="cov0" title="0">{

                mockdatas := []*movie.MovieAvaliable{
                        {
                                Movie_Id:  "test000000001",
                                Title:     "Lalaland",
                                CreatedAt: utils.GetLocaltime(),
                                UpdatedAt: utils.GetLocaltime(),
                                Showtime:  utils.SetSpecificTime(2024, 2, 19, 10, 30, 0),
                                SeatAvailable: []movie.SeatAvailable{
                                        {"A1": true},
                                        {"A2": true},
                                        {"A3": true},
                                        {"A4": true},
                                        {"A5": true},
                                        {"A6": true},
                                        {"A7": true},
                                        {"A8": true},
                                        {"A9": true},
                                        {"A10": true},
                                        {"A11": true},
                                        {"A12": true},
                                        {"B1": true},
                                        {"B2": true},
                                        {"B3": true},
                                        {"B4": true},
                                        {"B5": true},
                                        {"B6": true},
                                        {"B7": true},
                                        {"B8": true},
                                        {"B9": true},
                                        {"B10": true},
                                        {"B11": true},
                                        {"B12": true},
                                        {"C1": true},
                                        {"C2": true},
                                        {"C3": true},
                                        {"C4": true},
                                        {"C5": true},
                                        {"C6": true},
                                        {"C7": true},
                                        {"C8": true},
                                        {"C9": true},
                                        {"C10": true},
                                        {"C11": true},
                                        {"C12": true},
                                        {"D1": true},
                                        {"D2": true},
                                        {"D3": true},
                                        {"D4": true},
                                        {"D5": true},
                                        {"D6": true},
                                        {"D7": true},
                                        {"D8": true},
                                        {"D9": true},
                                        {"D10": true},
                                        {"D11": true},
                                        {"D12": true},
                                },
                        },
                        {
                                Movie_Id:  "test000000002",
                                Title:     "Lalaland",
                                CreatedAt: utils.GetLocaltime(),
                                UpdatedAt: utils.GetLocaltime(),
                                Showtime:  utils.SetSpecificTime(2024, 2, 19, 12, 30, 0),
                                SeatAvailable: []movie.SeatAvailable{
                                        {"A1": true},
                                        {"A2": true},
                                        {"A3": true},
                                        {"B1": true},
                                        {"B2": true},
                                        {"B3": true},
                                        {"C1": true},
                                        {"C2": true},
                                        {"C3": true},
                                        {"D1": true},
                                        {"D2": true},
                                        {"D3": true},
                                },
                        },
                        {
                                Movie_Id:  "test000000003",
                                Title:     "Lalaland",
                                CreatedAt: utils.GetLocaltime(),
                                UpdatedAt: utils.GetLocaltime(),
                                Showtime:  utils.SetSpecificTime(2024, 2, 19, 15, 30, 0),
                                SeatAvailable: []movie.SeatAvailable{
                                        {"A1": true},
                                        {"A2": true},
                                        {"A3": true},
                                        {"B1": true},
                                        {"B2": true},
                                        {"B3": true},
                                        {"C1": true},
                                        {"C2": true},
                                        {"C3": true},
                                        {"D1": true},
                                        {"D2": true},
                                        {"D3": true},
                                },
                        },
                }

                docs := make([]any, 0)
                for _, i := range mockdatas </span><span class="cov0" title="0">{
                        docs = append(docs, i)
                }</span>

                <span class="cov0" title="0">return docs</span>
        }()

        <span class="cov0" title="0">_, err = col.InsertMany(pctx, documents)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: CreateIndex Movie_available")
                panic(err)</span>
        }

        <span class="cov0" title="0">col = db.Collection("categories")

        _, err = col.Indexes().CreateOne(pctx, mongo.IndexModel{
                Keys: bson.D{{"name", 1}},
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: CreateIndex Failed")
                panic(err)</span>
        }

        <span class="cov0" title="0">documents = func() []any </span><span class="cov0" title="0">{
                mockData := []movie.Category{
                        {
                                Name: "Comedy",
                        },
                        {
                                Name: "Romantic",
                        },
                        {
                                Name: "Rom-Com",
                        },
                        {
                                Name: "Action",
                        },
                        {
                                Name: "Music",
                        },
                }

                docs := make([]any, 0)

                for _, i := range mockData </span><span class="cov0" title="0">{
                        docs = append(docs, i)
                }</span>

                <span class="cov0" title="0">return docs</span>

        }()

        <span class="cov0" title="0">_, err = col.InsertMany(pctx, documents)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: CreateIndex Failed")
                panic(err)</span>
        }

        <span class="cov0" title="0">log.Println("Migrate movies completed:", results)</span>

}
</pre>
		
		<pre class="file" id="file6" style="display: none">package migrate

import (
        "context"
        "log"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/database"
        "go.mongodb.org/mongo-driver/bson"
)

func PaymentMigrate(pctx context.Context, cfg *config.Config) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, 30*time.Second)
        defer cancel()

        db := database.DbConn(pctx, cfg).Database("payment_db")
        defer db.Client().Disconnect(pctx)

        col := db.Collection("payment_queue")
        result, err := col.InsertOne(ctx, bson.M{"offset": -1})

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">log.Println("Migrate Payment Db successfully", result)</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package migrate

import (
        "context"
        "log"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/database"
        "github.com/guatom999/TicketShop-Movie/modules/ticket"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
)

func TicketMigrate(pctx context.Context, cfg *config.Config) <span class="cov0" title="0">{

        db := database.DbConn(pctx, cfg).Database("ticket_db")
        defer db.Client().Disconnect(pctx)

        col := db.Collection("customer_ticket")

        _, err := col.Indexes().CreateOne(pctx, mongo.IndexModel{
                Keys: bson.D{{"_id", 1}},
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error : CreateIndex Failed :%s", err.Error())
                panic(err)</span>
        }

        <span class="cov0" title="0">documents := func() []any </span><span class="cov0" title="0">{
                mockdatas := []*ticket.Ticket{
                        {
                                MovieId:    "65ecc8b289430838d51441a2",
                                CustomerId: "65e8a18968027287072e87dd",
                                Seat:       "A1",
                                MovieName:  "FRIEREN",
                                Date:       "14/3/2024",
                                Time:       "15.30",
                                Price:      160,
                                CreatedAt:  utils.GetLocaltime(),
                                UpdatedAt:  utils.GetLocaltime(),
                        },
                }

                datas := make([]any, 0)
                for i := range mockdatas </span><span class="cov0" title="0">{
                        datas = append(datas, mockdatas[i])
                }</span>

                <span class="cov0" title="0">return datas</span>

        }()

        <span class="cov0" title="0">results, err := col.InsertMany(pctx, documents)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: CreateIndex Failed %s", err.Error())
                panic(err)</span>
        }

        <span class="cov0" title="0">log.Println("Migrate movies completed:", results)</span>

}
</pre>
		
		<pre class="file" id="file8" style="display: none">package redisConn

import (
        "context"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/redis/go-redis/v9"
)

func RedisConn(pctx context.Context, cfg *config.Config) *redis.Client <span class="cov0" title="0">{

        client := redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Redis.RedisUrl,
                Password: "",
                DB:       0,
        })

        return client

}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "context"
        "log"
        "os"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/database/migrate"
)

type Config struct {
        Db Db
}

type Db struct {
        Url string
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        path := func() string </span><span class="cov0" title="0">{
                if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                        log.Fatal("Error: .env path is required")
                }</span>
                <span class="cov0" title="0">log.Printf("choosen env is :%v", os.Args[1])
                return os.Args[1]</span>
        }()

        <span class="cov0" title="0">cfg := config.GetMigrateConfig(func() string </span><span class="cov0" title="0">{
                if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                        log.Fatal("Error: .env path is required")
                }</span>
                <span class="cov0" title="0">log.Printf("choosen env is :%v", os.Args[1])
                return os.Args[1]</span>
        }())

        <span class="cov0" title="0">switch path </span>{
        case "movie":<span class="cov0" title="0">
                migrate.MovieMigrate(ctx, &amp;cfg)</span>
        case "booking":<span class="cov0" title="0">
                migrate.BookingMigrate(ctx, &amp;cfg)</span>
        case "inventory":<span class="cov0" title="0">
                migrate.InventoryMigrate(ctx, &amp;cfg)</span>
        case "customer":<span class="cov0" title="0">
                migrate.CustomerMigrate(ctx, &amp;cfg)</span>
        case "ticket":<span class="cov0" title="0">
                migrate.TicketMigrate(ctx, &amp;cfg)</span>
        case "payment":<span class="cov0" title="0">
                migrate.PaymentMigrate(ctx, &amp;cfg)</span>
        }

}

// func GetConfig(path string) config.Config {
//         viper.SetConfigName(fmt.Sprintf(".env.%s", path))
//         viper.SetConfigType("env")

//         viper.AddConfigPath("../../env")
//         viper.AutomaticEnv()

//         err := viper.ReadInConfig()
//         if err != nil {
//                 log.Fatalf("fatal error config file: %s", err.Error())
//                 panic(err)
//         }

//         return Config{
//                 Db: Db{
//                         Url: viper.GetString("DB_URL"),
//                 },
//         }

// }
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "context"
        "log"
        "os"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/database"
        "github.com/guatom999/TicketShop-Movie/database/redisConn"
        "github.com/guatom999/TicketShop-Movie/pkg/opn"
        "github.com/guatom999/TicketShop-Movie/server"
        "github.com/guatom999/TicketShop-Movie/utils"
)

func main() <span class="cov0" title="0">{

        ctx := context.Background()

        cfg := config.GetConfig(func() string </span><span class="cov0" title="0">{
                if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                        log.Fatal("Error: .env path is required")
                }</span>
                <span class="cov0" title="0">log.Printf("choosen env is :%v", os.Args[1])
                return os.Args[1]</span>
        }())

        <span class="cov0" title="0">db := database.DbConn(ctx, &amp;cfg)

        defer db.Disconnect(ctx)

        redis := redisConn.RedisConn(ctx, &amp;cfg)

        mailer := utils.ConnectToMailer(&amp;cfg)

        omiseClient := opn.OmiseConn(&amp;cfg)

        server.NewEchoServer(db, &amp;cfg, omiseClient, redis, mailer).Start(ctx)</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">package authHandlers

import "github.com/guatom999/TicketShop-Movie/modules/auth/authUseCases"

type (
        AuthHandlerService interface {
        }

        authHandler struct {
                authUseCase authUseCases.AuthUseCaseService
        }
)

func NewAuthHandler(authUseCase authUseCases.AuthUseCaseService) AuthHandlerService <span class="cov0" title="0">{
        return &amp;authHandler{authUseCase}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package authRepositories

import (
        "context"

        "github.com/guatom999/TicketShop-Movie/modules/auth"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type (
        AuthRepositoryService interface {
                Register(pctx context.Context, req *auth.RegisterRequest) (primitive.ObjectID, error)
        }

        authRepository struct {
                db *mongo.Client
        }
)

func NewAuthRepository() AuthRepositoryService <span class="cov0" title="0">{
        return &amp;authRepository{}
}</span>

func (r *authRepository) Register(pctx context.Context, req *auth.RegisterRequest) (primitive.ObjectID, error) <span class="cov0" title="0">{

        // ctx, cancel := context.WithTimeout(pctx, time.Second*10)
        // defer cancel()

        // db := r.db.Database("")

        return primitive.NilObjectID, nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package authUseCases

import "github.com/guatom999/TicketShop-Movie/modules/auth/authRepositories"

type (
        AuthUseCaseService interface {
        }

        authUseCase struct {
                authRepo authRepositories.AuthRepositoryService
        }
)

func NewUuthUseCase(authRepo authRepositories.AuthRepositoryService) AuthUseCaseService <span class="cov0" title="0">{
        return &amp;authUseCase{authRepo: authRepo}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package bookHandlers

import (
        "net/http"

        "github.com/guatom999/TicketShop-Movie/modules/book/bookUseCases"
        "github.com/labstack/echo/v4"
)

type (
        BookHandlerService interface {
                BuyTicket(c echo.Context) error
        }

        bookHandler struct {
                bookUseCases bookUseCases.BookUseCaseService
        }
)

func NewBookHandler(bookUseCases bookUseCases.BookUseCaseService) BookHandlerService <span class="cov0" title="0">{
        return &amp;bookHandler{bookUseCases: bookUseCases}
}</span>

func (u *bookHandler) BuyTicket(c echo.Context) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, "")
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package bookRepositories

import (
        "context"
        "fmt"
        "io/ioutil"
        "log"
        "net/http"
        "time"

        "go.mongodb.org/mongo-driver/mongo"
)

type (
        BookRepositoryService interface {
        }

        bookRepository struct {
                db *mongo.Client
        }
)

func NewBookRepository() BookRepositoryService <span class="cov0" title="0">{
        return &amp;bookRepository{}
}</span>

func (r *bookRepository) ConnectBookingDb() *mongo.Database <span class="cov0" title="0">{
        return r.db.Database("booking_db")
}</span>

func (r *bookRepository) FindMovieIsAvaliable(title string) error <span class="cov0" title="0">{

        client := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        resp, err := client.Get(fmt.Sprintf("http://localhost:8090/getmovie/%s", title))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending GET request: %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">defer resp.Body.Close()

        _, err = ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading response body: %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (r *bookRepository) ReserveSeat(pctx context.Context) {<span class="cov0" title="0">

}</span>

func (r *bookRepository) BuyTicket(pctx context.Context, title string) error <span class="cov0" title="0">{

        return nil

}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package bookUseCases

import "github.com/guatom999/TicketShop-Movie/modules/book/bookRepositories"

type (
        BookUseCaseService interface {
        }

        bookUsecase struct {
                bookRepo bookRepositories.BookRepositoryService
        }
)

func NewBookUsecase(bookRepo bookRepositories.BookRepositoryService) BookUseCaseService <span class="cov0" title="0">{
        return &amp;bookUsecase{bookRepo: bookRepo}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package customerHandlers

import (
        "context"
        "fmt"
        "net/http"
        "strings"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/customer"
        "github.com/guatom999/TicketShop-Movie/modules/customer/customerUseCases"
        "github.com/labstack/echo/v4"
        "github.com/labstack/gommon/log"
)

type (
        CustomerHandlerService interface {
                Login(c echo.Context) error
                RefreshToken(c echo.Context) error
                Logout(c echo.Context) error
                GetCustomerProfile(c echo.Context) error
                TestMilddeware(next echo.HandlerFunc) echo.HandlerFunc
                TestJwtAuthorize(c echo.Context) error
                Register(c echo.Context) error
                FindAccessToken(c echo.Context) error
                ForgotPassword(c echo.Context) error
                HealthCheck(c echo.Context) error
        }

        customerHandler struct {
                customerUseCase customerUseCases.CustomerUseCaseService
                cfg             *config.Config
        }
)

func NewCustomerHandler(customerUseCase customerUseCases.CustomerUseCaseService, cfg *config.Config) CustomerHandlerService <span class="cov0" title="0">{
        return &amp;customerHandler{
                customerUseCase: customerUseCase,
                cfg:             cfg,
        }
}</span>

func (h *customerHandler) HealthCheck(c echo.Context) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, "status ok")
}</span>

func (h *customerHandler) GetCustomerProfile(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        customerId := c.Param("customer_id")

        result, err := h.customerUseCase.GetCustomerProfile(ctx, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, result)</span>

}
func (h *customerHandler) Login(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        req := new(customer.LoginReq)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, "something weng wrong")
        }</span>

        <span class="cov0" title="0">res, err := h.customerUseCase.Login(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, res)</span>
}

func (h *customerHandler) TestJwtAuthorize(c echo.Context) error <span class="cov0" title="0">{

        return c.JSON(http.StatusOK, "test success")
}</span>

func (h *customerHandler) RefreshToken(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        req := new(customer.CustomerRefreshTokenReq)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                log.Printf("req wrong cause of :++++&gt;", err.Error())
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">res, err := h.customerUseCase.RefreshToken(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, res)</span>
}

func (h *customerHandler) Logout(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        req := new(customer.LogoutReq)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">res, err := h.customerUseCase.Logout(ctx, req.CredentialId)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, fmt.Sprintf("Logout success Deleted user count %d", res))</span>
}

func (h *customerHandler) FindAccessToken(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        req := new(customer.FindAccessTokenReq)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">result, err := h.customerUseCase.FindAccessToken(ctx, req.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, result)</span>
}

func (h *customerHandler) TestMilddeware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                accessToken := strings.TrimPrefix(c.Request().Header.Get("Authorization"), "Bearer ")

                result, err := h.customerUseCase.TestMiddleware(c, accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, err.Error())
                }</span>

                <span class="cov0" title="0">return next(result)</span>

        }
}

func (h *customerHandler) Register(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        req := new(customer.RegisterReq)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">result, err := h.customerUseCase.Register(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusCreated, result)</span>
}

func (h *customerHandler) ForgotPassword(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        req := new(customer.SendForgotPasswordReq)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">if err := h.customerUseCase.ForgotPassword(ctx, req.Email); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, "send email success")</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package customerRepositories

import (
        "context"
        "errors"
        "log"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/customer"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type (
        CustomerRepositoryService interface {
                FindOneCustomerWithCredential(pctx context.Context, email string) (*customer.Customer, error)
                InsertCustomer(pctx context.Context, req *customer.Customer) (primitive.ObjectID, error)
                FindCustomer(pctx context.Context, customerId string) (*customer.Customer, error)
                InsertCustomerCredential(pctx context.Context, req *customer.Credential) (primitive.ObjectID, error)
                DeleteCustomerCredential(pctx context.Context, credentialId string) (int64, error)
                FindAccessToken(pctx context.Context, accessToken string) (*customer.Credential, error)
                FindCustomerCredential(pctx context.Context, credentialId string) (*customer.Credential, error)
                UpdateCustomerCredential(pctx context.Context, credentialId string, req *customer.UpdateRefreshToken) error
                ForgotPassword(pctx context.Context, email string) error
                NewAccessToken(cfg *config.Config, customerPassport *customer.Claims) string
                NewRefreshToken(cfg *config.Config, customerPassport *customer.Claims) string
                ReloadToken(cfg *config.Config, customerPassport *customer.Claims) string
                IsUserAlreadyExist(pctx context.Context, username, email string) bool
        }

        customerRepository struct {
                db  *mongo.Client
                cfg *config.Config
        }
)

func NewCustomerRepository(db *mongo.Client, cfg *config.Config) CustomerRepositoryService <span class="cov0" title="0">{

        return &amp;customerRepository{db: db, cfg: cfg}

}</span>

func (r *customerRepository) AddTicketCustomer(pctx context.Context) error <span class="cov0" title="0">{

        // ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        // defer cancel()

        // db := r.db.Database("movie_db")
        // col := db.Collection("movie")

        return nil

}</span>

func (r *customerRepository) FindOneCustomerCredential(pctx context.Context, customerId string) (*customer.Credential, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer_auth")

        result := new(customer.Credential)

        if err := col.FindOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(customerId)}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: FindOneCustomerCredential Failed %s", err.Error())
                return nil, errors.New("error: find credentail customer failed")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *customerRepository) InsertCustomerCredential(pctx context.Context, req *customer.Credential) (primitive.ObjectID, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        req.CreatedAt = utils.GetLocaltime()
        req.UpdatedAt = utils.GetLocaltime()

        db := r.db.Database("customer_db")
        col := db.Collection("customer_auth")

        result, err := col.InsertOne(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: InsertCustomerCredential Failed %s", err.Error())
                return primitive.NilObjectID, errors.New("error: insert credentail customer failed")
        }</span>

        <span class="cov0" title="0">return result.InsertedID.(primitive.ObjectID), nil</span>
}

func (r *customerRepository) DeleteCustomerCredential(pctx context.Context, credentialId string) (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer_auth")

        result, err := col.DeleteOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(credentialId)})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: DeleteCustomerCredential Failed %s", err.Error())
                return 0, errors.New("error: delete customer credential failed")
        }</span>

        <span class="cov0" title="0">return result.DeletedCount, nil</span>
}

func (r *customerRepository) FindCustomerCredential(pctx context.Context, credentialId string) (*customer.Credential, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer_auth")

        result := new(customer.Credential)

        if err := col.FindOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(credentialId)}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: FindCustomerCredential Failed %s", err.Error())
                return nil, errors.New("error: find  customer credential failed")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *customerRepository) UpdateCustomerCredential(pctx context.Context, credentialId string, req *customer.UpdateRefreshToken) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer_auth")

        _, err := col.UpdateOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(credentialId)}, bson.M{"$set": bson.M{
                // "customer_id":   "customer:" + req.CustomerId,
                "access_token":  req.AccessToken,
                "refresh_token": req.RefreshToken,
                "updated_at":    req.UpdatedAt,
        }})

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: UpdateCustomerCredential Failed %s", err.Error())
                return errors.New("error: update customer credential failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *customerRepository) FindOneCustomerWithCredential(pctx context.Context, email string) (*customer.Customer, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer")

        result := new(customer.Customer)

        if err := col.FindOne(ctx, bson.M{"email": email}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: FindOneCustomerWithCredential Failed %s", err.Error())
                return nil, errors.New("error: find customer failed")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *customerRepository) FindCustomer(pctx context.Context, customerId string) (*customer.Customer, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*10)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer")

        result := new(customer.Customer)

        if err := col.FindOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(customerId)}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: FindCustomerRefreshToken Failed %s", err.Error())
                return nil, errors.New("error: find customer for refresh failed")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *customerRepository) NewAccessToken(cfg *config.Config, customerPassport *customer.Claims) string <span class="cov0" title="0">{

        claims := customer.AuthClaims{
                Claims: &amp;customer.Claims{
                        Id: customerPassport.Id,
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "seeyarnmirttown.com",
                        Subject:   "access-token",
                        Audience:  []string{"seeyarnmirttown.com"},
                        ExpiresAt: jwt.NewNumericDate(utils.GetLocaltime().Add(time.Second * time.Duration(cfg.Jwt.AccessDuration))),
                        NotBefore: jwt.NewNumericDate(utils.GetLocaltime()),
                        IssuedAt:  jwt.NewNumericDate(utils.GetLocaltime()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        accessToken, err := token.SignedString([]byte(cfg.Jwt.AccessSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: SignedToken Failed %s", err.Error())
                return err.Error()
        }</span>

        <span class="cov0" title="0">return accessToken</span>
}

func (r *customerRepository) NewRefreshToken(cfg *config.Config, customerPassport *customer.Claims) string <span class="cov0" title="0">{
        claims := customer.AuthClaims{
                Claims: &amp;customer.Claims{
                        Id: customerPassport.Id,
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "seeyarnmirttown.com",
                        Subject:   "refresh-token",
                        Audience:  []string{"seeyarnmirttown.com"},
                        ExpiresAt: jwt.NewNumericDate(utils.GetLocaltime().Add(time.Second * time.Duration(cfg.Jwt.RefreshDuration))),
                        NotBefore: jwt.NewNumericDate(utils.GetLocaltime()),
                        IssuedAt:  jwt.NewNumericDate(utils.GetLocaltime()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        refreshToken, err := token.SignedString([]byte(cfg.Jwt.RefreshSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: SignedToken Failed %s", err.Error())
                return err.Error()
        }</span>

        <span class="cov0" title="0">return refreshToken</span>
}

func (r *customerRepository) ReloadToken(cfg *config.Config, customerPassport *customer.Claims) string <span class="cov0" title="0">{

        claims := customer.AuthClaims{
                Claims: &amp;customer.Claims{
                        Id: customerPassport.Id,
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "seeyarnmirttown.com",
                        Subject:   "refresh-token",
                        Audience:  []string{"seeyarnmirttown.com"},
                        ExpiresAt: jwt.NewNumericDate(utils.GetLocaltime().Add(time.Second * 60)),
                        NotBefore: jwt.NewNumericDate(utils.GetLocaltime()),
                        IssuedAt:  jwt.NewNumericDate(utils.GetLocaltime()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        reloadToken, err := token.SignedString([]byte(cfg.Jwt.RefreshSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Reoload Token Failed %s", err.Error())
                return err.Error()
        }</span>

        <span class="cov0" title="0">return reloadToken</span>
}

func (r *customerRepository) FindAccessToken(pctx context.Context, accessToken string) (*customer.Credential, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(pctx, time.Second*10)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer_auth")

        result := new(customer.Credential)

        if err := col.FindOne(ctx, bson.M{"access_token": accessToken}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: FindAccessToken Failed %s", err.Error())
                return nil, errors.New("error: email or password invalid")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (r *customerRepository) InsertCustomer(pctx context.Context, req *customer.Customer) (primitive.ObjectID, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer")

        customerId, err := col.InsertOne(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: error insert one customer failed %s", err)
                return primitive.NilObjectID, errors.New("error: register failed")
        }</span>

        <span class="cov0" title="0">return customerId.InsertedID.(primitive.ObjectID), nil</span>
}

func (r *customerRepository) ForgotPassword(pctx context.Context, email string) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer")

        _, err := col.UpdateOne(ctx, bson.M{"email": email}, bson.M{"$set": bson.M{
                "password":   "123456",
                "updated_at": utils.GetLocaltime(),
        }})

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: ForgotPassword Failed %s", err.Error())
                return errors.New("error: forgot password failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *customerRepository) IsUserAlreadyExist(pctx context.Context, username, email string) bool <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("customer_db")
        col := db.Collection("customer")

        customer := new(customer.Customer)

        if err := col.FindOne(ctx, bson.M{"$or": []bson.M{
                {"email": email},
                {"username": username},
        },
        },
        ).Decode(customer); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: This use is not exits: %v", err.Error())
                return false
        }</span>

        <span class="cov0" title="0">return true</span>

}
</pre>
		
		<pre class="file" id="file19" style="display: none">package customerRepositories

import (
        "context"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/customer"
        "github.com/stretchr/testify/mock"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

type (
        CustomerRepositoryMock struct {
                mock.Mock
        }
)

func NewCustomerRepoMock() CustomerRepositoryService <span class="cov0" title="0">{
        return &amp;CustomerRepositoryMock{}
}</span>

func (m *CustomerRepositoryMock) FindOneCustomerWithCredential(pctx context.Context, email string) (*customer.Customer, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (m *CustomerRepositoryMock) InsertCustomer(pctx context.Context, req *customer.Customer) (primitive.ObjectID, error) <span class="cov0" title="0">{
        return primitive.NilObjectID, nil
}</span>
func (m *CustomerRepositoryMock) FindCustomer(pctx context.Context, customerId string) (*customer.Customer, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (m *CustomerRepositoryMock) InsertCustomerCredential(pctx context.Context, req *customer.Credential) (primitive.ObjectID, error) <span class="cov0" title="0">{
        return primitive.NilObjectID, nil
}</span>
func (m *CustomerRepositoryMock) DeleteCustomerCredential(pctx context.Context, credentialId string) (int64, error) <span class="cov0" title="0">{
        return 0, nil
}</span>
func (m *CustomerRepositoryMock) FindAccessToken(pctx context.Context, accessToken string) (*customer.Credential, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (m *CustomerRepositoryMock) FindCustomerCredential(pctx context.Context, credentialId string) (*customer.Credential, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (m *CustomerRepositoryMock) UpdateCustomerCredential(pctx context.Context, credentialId string, req *customer.UpdateRefreshToken) error <span class="cov0" title="0">{
        return nil
}</span>
func (m *CustomerRepositoryMock) ForgotPassword(pctx context.Context, email string) error <span class="cov0" title="0">{
        return nil
}</span>
func (m *CustomerRepositoryMock) NewAccessToken(cfg *config.Config, customerPassport *customer.Claims) string <span class="cov0" title="0">{
        return ""
}</span>
func (m *CustomerRepositoryMock) NewRefreshToken(cfg *config.Config, customerPassport *customer.Claims) string <span class="cov0" title="0">{
        return ""
}</span>
func (m *CustomerRepositoryMock) ReloadToken(cfg *config.Config, customerPassport *customer.Claims) string <span class="cov0" title="0">{
        return ""
}</span>
func (m *CustomerRepositoryMock) IsUserAlreadyExist(pctx context.Context, username, email string) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package customerUseCases

import (
        "context"
        "errors"
        "log"
        "strings"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/customer"
        "github.com/guatom999/TicketShop-Movie/modules/customer/customerRepositories"
        "github.com/guatom999/TicketShop-Movie/pkg/jwtauth"
        "github.com/guatom999/TicketShop-Movie/utils"
        "github.com/labstack/echo/v4"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "golang.org/x/crypto/bcrypt"
        "gopkg.in/gomail.v2"
)

type (
        CustomerUseCaseService interface {
                Login(pctx context.Context, req *customer.LoginReq) (*customer.CustomerProfileRes, error)
                Logout(pctx context.Context, credentialId string) (int64, error)
                GetCustomerProfile(pctx context.Context, customerId string) (*customer.CustomerProfile, error)
                FindAccessToken(pctx context.Context, accessToken string) (*customer.Credential, error)
                Register(pctx context.Context, req *customer.RegisterReq) (primitive.ObjectID, error)
                RefreshToken(pctx context.Context, req *customer.CustomerRefreshTokenReq) (*customer.CustomerProfileRes, error)
                TestMiddleware(c echo.Context, accessToken string) (echo.Context, error)
                ForgotPassword(pctx context.Context, sendTo string) error
        }

        customerUseCase struct {
                customerRepo customerRepositories.CustomerRepositoryService
                cfg          *config.Config
                mailer       *gomail.Dialer
        }
)

func NewCustomerUseCase(customerRepo customerRepositories.CustomerRepositoryService, cfg *config.Config, mailer *gomail.Dialer) CustomerUseCaseService <span class="cov0" title="0">{
        return &amp;customerUseCase{
                customerRepo: customerRepo,
                cfg:          cfg,
                mailer:       mailer,
        }
}</span>

func (u *customerUseCase) Login(pctx context.Context, req *customer.LoginReq) (*customer.CustomerProfileRes, error) <span class="cov0" title="0">{

        result, err := u.customerRepo.FindOneCustomerWithCredential(pctx, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">customerId := "customer:" + result.Id.Hex()

        if err := bcrypt.CompareHashAndPassword([]byte(result.Password), []byte(req.Password)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("error: password mismatch")
        }</span>

        <span class="cov0" title="0">accessToken := u.customerRepo.NewAccessToken(u.cfg, &amp;customer.Claims{
                Id: result.Id.Hex(),
        })

        refreshToken := u.customerRepo.NewRefreshToken(u.cfg, &amp;customer.Claims{
                Id: result.Id.Hex(),
        })

        credential, _ := u.customerRepo.InsertCustomerCredential(pctx, &amp;customer.Credential{
                CustomerId:   customerId,
                Rolecode:     1,
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        })

        customerCredential, err := u.customerRepo.FindCustomerCredential(pctx, credential.Hex())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // loc, _ := time.LoadLocation("Asia/Bangkok")

        <span class="cov0" title="0">return &amp;customer.CustomerProfileRes{
                Status: "ok",
                CustomerProfile: &amp;customer.CustomerProfile{
                        Id:         credential.Hex(),
                        CustomerId: customerId,
                        Email:      result.Email,
                        ImageUrl:   result.ImageUrl,
                        UserName:   result.UserName,
                        Created_At: utils.GetStringTime(result.Created_At),
                        Updated_At: utils.GetStringTime(result.Updated_At),
                        Credential: &amp;customer.CredentailRes{
                                AccessToken:  customerCredential.AccessToken,
                                RefreshToken: customerCredential.RefreshToken,
                        },
                },
        }, nil</span>
}

func (u *customerUseCase) Logout(pctx context.Context, credentialId string) (int64, error) <span class="cov0" title="0">{

        return u.customerRepo.DeleteCustomerCredential(pctx, credentialId)
}</span>

// func (u *customerUseCase) GetCustomerProfile(pctx context.Context, customerId string) (*customer.CustomerProfile, error) {

//         result, err := u.customerRepo.FindCustomer(pctx, customerId)
//         if err != nil {
//                 return nil, err
//         }

//         return &amp;customer.CustomerProfile{
//                 Id:         result.Id.Hex(),
//                 CustomerId: customerId,
//                 Email:      result.Email,
//                 ImageUrl:   result.ImageUrl,
//                 UserName:   result.UserName,
//                 Created_At: utils.GetStringTime(result.Created_At),
//                 Updated_At: utils.GetStringTime(result.Updated_At),
//         }, nil
// }

func (u *customerUseCase) GetCustomerProfile(pctx context.Context, customerId string) (*customer.CustomerProfile, error) <span class="cov0" title="0">{

        result, err := u.customerRepo.FindCustomer(pctx, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;customer.CustomerProfile{
                Id:         result.Id.Hex(),
                CustomerId: customerId,
                Email:      result.Email,
                ImageUrl:   result.ImageUrl,
                UserName:   result.UserName,
                Created_At: utils.GetStringTime(result.Created_At),
                Updated_At: utils.GetStringTime(result.Updated_At),
        }, nil</span>
}

func (u *customerUseCase) RefreshToken(pctx context.Context, req *customer.CustomerRefreshTokenReq) (*customer.CustomerProfileRes, error) <span class="cov0" title="0">{

        _, err := jwtauth.ParseToken(u.cfg.Jwt.RefreshSecretKey, req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // fmt.Println("after trim Prefix is", strings.TrimPrefix(req.CustomerId, "customer:"))

        <span class="cov0" title="0">customerProfile, err := u.customerRepo.FindCustomer(pctx, strings.TrimPrefix(req.CustomerId, "customer:"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">customerId := "customer:" + customerProfile.Id.Hex()

        accessToken := u.customerRepo.NewAccessToken(u.cfg, &amp;customer.Claims{
                Id: customerId,
        })

        refreshToken := u.customerRepo.ReloadToken(u.cfg, &amp;customer.Claims{
                Id: customerId,
        })

        if err := u.customerRepo.UpdateCustomerCredential(pctx, req.CredentialId, &amp;customer.UpdateRefreshToken{
                CustomerId:   customerProfile.Id.Hex(),
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                UpdatedAt:    utils.GetLocaltime(),
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">customerCredential, err := u.customerRepo.FindCustomerCredential(pctx, req.CredentialId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;customer.CustomerProfileRes{
                Status: "ok",
                CustomerProfile: &amp;customer.CustomerProfile{
                        Id:         customerProfile.Id.Hex(),
                        CustomerId: customerId,
                        Email:      customerProfile.Email,
                        ImageUrl:   customerProfile.ImageUrl,
                        UserName:   customerProfile.UserName,
                        Created_At: utils.GetStringTime(customerProfile.Created_At),
                        Updated_At: utils.GetStringTime(customerProfile.Updated_At),
                        Credential: &amp;customer.CredentailRes{
                                AccessToken:  customerCredential.AccessToken,
                                RefreshToken: customerCredential.RefreshToken,
                        },
                },
        }, nil</span>
}

func (u *customerUseCase) FindAccessToken(pctx context.Context, accessToken string) (*customer.Credential, error) <span class="cov0" title="0">{
        return u.customerRepo.FindAccessToken(pctx, accessToken)
}</span>

func (u *customerUseCase) TestMiddleware(c echo.Context, accessToken string) (echo.Context, error) <span class="cov0" title="0">{

        ctx := c.Request().Context()

        claims, err := jwtauth.ParseToken(u.cfg.Jwt.AccessSecretKey, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Erorr is %s", err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := u.customerRepo.FindAccessToken(ctx, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if result == nil </span><span class="cov0" title="0">{
                return nil, errors.New("errro: access token is invalid")
        }</span>

        <span class="cov0" title="0">c.Set("customer_id", claims.CustomerId)

        return c, nil</span>
}
func (u *customerUseCase) Register(pctx context.Context, req *customer.RegisterReq) (primitive.ObjectID, error) <span class="cov0" title="0">{

        if u.customerRepo.IsUserAlreadyExist(pctx, req.UserName, req.Email) </span><span class="cov0" title="0">{
                return primitive.NilObjectID, errors.New("error: user already exist")
        }</span>

        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), 10)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: hashedPassword failed %s", err.Error())
                return primitive.NilObjectID, errors.New("error: something wrong with password")
        }</span>

        <span class="cov0" title="0">result, err := u.customerRepo.InsertCustomer(pctx, &amp;customer.Customer{
                UserName:   req.UserName,
                Email:      req.Email,
                ImageUrl:   "https://t4.ftcdn.net/jpg/05/49/98/39/360_F_549983970_bRCkYfk0P6PP5fKbMhZMIb07mCJ6esXL.jpg",
                Password:   string(hashedPassword),
                Created_At: utils.GetLocaltime(),
                Updated_At: utils.GetLocaltime(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return primitive.NilObjectID, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (u *customerUseCase) ForgotPassword(pctx context.Context, sendTo string) error <span class="cov0" title="0">{

        if !u.customerRepo.IsUserAlreadyExist(pctx, "", sendTo) </span><span class="cov0" title="0">{
                return errors.New("error: user not found")
        }</span>

        <span class="cov0" title="0">toSendMessage := gomail.NewMessage()
        toSendMessage.SetHeader("To", sendTo)
        toSendMessage.SetHeader("Subject", "Why you forgot password")
        toSendMessage.SetBody("text/html", "You password is")

        if err := utils.SecondSendEmail(u.cfg, toSendMessage); err != nil </span><span class="cov0" title="0">{
                log.Printf("Errors TestSendEmail is %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package inventoryHandlers

import (
        "context"
        "net/http"

        "github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryUseCases"
        "github.com/labstack/echo/v4"
)

type (
        InventoryHandlerService interface {
                GetCustomerTicket(c echo.Context) error
                FindLastCustomerTicket(c echo.Context) error
                HealthCheck(c echo.Context) error
        }

        inventoryHandler struct {
                inventoryUseCase inventoryUseCases.InventoryUseCaseService
        }
)

func NewInventoryHandler(inventoryUseCase inventoryUseCases.InventoryUseCaseService) InventoryHandlerService <span class="cov0" title="0">{
        return &amp;inventoryHandler{inventoryUseCase: inventoryUseCase}
}</span>

func (h *inventoryHandler) HealthCheck(c echo.Context) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, "status ok")
}</span>

func (h *inventoryHandler) GetCustomerTicket(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        customerId := c.Param("customerid")

        results, err := h.inventoryUseCase.GetCustomerTicket(ctx, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, results)</span>
}

func (h *inventoryHandler) GetCustomerTicketDetail(c echo.Context) error <span class="cov0" title="0">{

        return nil

}</span>

func (h *inventoryHandler) FindLastCustomerTicket(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        customerId := c.Param("customerid")

        results, err := h.inventoryUseCase.FindLastCustomerTicket(ctx, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, results)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package inventoryHandlers

import (
        "context"
        "encoding/json"
        "fmt"
        "log"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/inventory"
        "github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryUseCases"
        "github.com/guatom999/TicketShop-Movie/pkg/queue"
)

type (
        InventoryQueueHanlderService interface {
                AddCustomerTransaction()
        }

        inventoryQueueHanlder struct {
                cfg              *config.Config
                inventoryUseCase inventoryUseCases.InventoryUseCaseService
        }
)

func NewInventoryQueueHandler(cfg *config.Config, inventoryUseCase inventoryUseCases.InventoryUseCaseService) InventoryQueueHanlderService <span class="cov0" title="0">{
        return &amp;inventoryQueueHanlder{
                cfg:              cfg,
                inventoryUseCase: inventoryUseCase,
        }
}</span>

func (h *inventoryQueueHanlder) AddCustomerTransaction() <span class="cov0" title="0">{

        ctx := context.Background()

        data := new(inventory.AddCustomerTicketReq)

        reader := queue.KafkaReader(h.cfg, "add-ticket", "inventory-group")
        defer reader.Close()

        for </span><span class="cov0" title="0">{

                message, err := reader.ReadMessage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error reading message: %s", err.Error())
                        break</span>
                }

                <span class="cov0" title="0">if err := json.Unmarshal(message.Value, data); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: Unmarshal error %s", err.Error())
                }</span>

                <span class="cov0" title="0">h.inventoryUseCase.AddCustomerTicket(ctx, data)</span>

        }

}
</pre>
		
		<pre class="file" id="file23" style="display: none">package inventoryRepositories

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/guatom999/TicketShop-Movie/modules/inventory"
        "github.com/guatom999/TicketShop-Movie/pkg/rest"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type (
        InventoryRepositoryService interface {
                GetCustomerTicket(pctx context.Context, customerID string) ([]*inventory.CustomerTikcetRes, error)
                // FindLastCustomerTicket(pctx context.Context, customerId string, opts []*options.FindOneOptions) (*inventory.CustomerTikcetRes, error)
                // FindLastCustomerTicket(pctx context.Context, customerId string, opts any) (*inventory.CustomerTikcetRes, error)
                FindLastCustomerTicket(pctx context.Context, customerId string, opts []*options.FindOneOptions) (*inventory.CustomerTikcetRes, error)
                AddCustomerTicket(pctx context.Context, req *inventory.CustomerTicket) (primitive.ObjectID, error)
        }

        inventoryRepository struct {
                db *mongo.Client
        }
)

func NewInventoryRepository(db *mongo.Client) InventoryRepositoryService <span class="cov0" title="0">{
        return &amp;inventoryRepository{db: db}
}</span>

// func DbConnect(pctx context.Context, dbName string) *mongo.Collection {
//         db := r.db.Database("inventory_db")
// }

// func (r *inventoryRepository) FindOneCustomerTicket(pctx context.Context, orderId)

func (r *inventoryRepository) FindOneTicketDetail(pctx context.Context, ticketId string) (*inventory.CustomerTikcetRes, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*10)
        defer cancel()

        db := r.db.Database("inventory_db")
        col := db.Collection("ticket_inventory")

        result := new(inventory.CustomerTicket)

        if err := col.FindOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(ticketId)}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: find one ticket failed :%s", err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;inventory.CustomerTikcetRes{}, nil</span>
}

func (r *inventoryRepository) findMovieDetail(movieId string) error <span class="cov0" title="0">{

        result, err := rest.ReqWithParams("http://localhost:8090/movie/getmovie/", movieId)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: find one movie failed :%s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Result:", result)

        return nil</span>
}

func (r *inventoryRepository) GetCustomerTicket(pctx context.Context, customerID string) ([]*inventory.CustomerTikcetRes, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*30)
        defer cancel()

        db := r.db.Database("inventory_db")
        col := db.Collection("ticket_inventory")

        cur, err := col.Find(ctx, bson.M{"customer_id": customerID})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Failed to find Customer Ticket %s", err.Error())
                return make([]*inventory.CustomerTikcetRes, 0), nil
        }</span>

        <span class="cov0" title="0">results := make([]*inventory.CustomerTikcetRes, 0)

        for cur.Next(ctx) </span><span class="cov0" title="0">{
                result := new(inventory.CustomerTicket)
                if err := cur.Decode(result); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error: Failed to Decode From Finding %s", err.Error())
                        return make([]*inventory.CustomerTikcetRes, 0), nil
                }</span>

                <span class="cov0" title="0">results = append(results, &amp;inventory.CustomerTikcetRes{
                        TicketId:      result.Id.Hex(),
                        OrderNumber:   result.OrderNumber,
                        MovieId:       result.MovieId,
                        MovieName:     result.MovieName,
                        MovieImage:    result.PosterUrl,
                        MovieDate:     result.MovieDate,
                        MovieShowTime: result.MovieShowTime,
                        Ticket_Image:  result.Ticket_Image,
                        Created_At:    utils.GetStringTime(result.Created_At),
                        Price:         result.Price,
                        Seat:          result.Seat,
                })</span>

        }

        <span class="cov0" title="0">return results, nil</span>

}

// func (r *inventoryRepository) FindLastCustomerTicket(pctx context.Context, filter any, opts []*options.FindOneOptions) (*inventory.CustomerTikcetRes, error) {
func (r *inventoryRepository) FindLastCustomerTicket(pctx context.Context, customerId string, opts []*options.FindOneOptions) (*inventory.CustomerTikcetRes, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("inventory_db")
        col := db.Collection("ticket_inventory")

        // filter := bson.M{"customer_id": customerId}

        // sort := bson.M{"created_at": -1}

        // result := new(inventory.CustomerTikcetRes)
        result := new(inventory.CustomerTicket)

        if err := col.FindOne(ctx, bson.M{"customer_id": customerId}, opts...).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Failed to Decode From Finding %s", err.Error())
                return nil, nil
        }</span>

        <span class="cov0" title="0">return &amp;inventory.CustomerTikcetRes{
                MovieId:      result.MovieId,
                MovieName:    result.MovieName,
                Ticket_Image: result.Ticket_Image,
                Created_At:   utils.GetStringTime(result.Created_At),
                Price:        result.Price / 100,
                Seat:         result.Seat,
        }, nil</span>
}

func (r *inventoryRepository) AddCustomerTicket(pctx context.Context, req *inventory.CustomerTicket) (primitive.ObjectID, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("inventory_db")
        col := db.Collection("ticket_inventory")

        result, err := col.InsertOne(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: Insert Customer Ticket Failed: %s", err.Error())
                return primitive.NilObjectID, errors.New("error: insert ticket failed")
        }</span>

        <span class="cov0" title="0">return result.InsertedID.(primitive.ObjectID), nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package inventoryUseCases

import (
        "context"
        "fmt"
        "log"
        "strings"

        "github.com/guatom999/TicketShop-Movie/modules/inventory"
        "github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryRepositories"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type (
        InventoryUseCaseService interface {
                GetCustomerTicket(pctx context.Context, customerId string) ([]*inventory.CustomerTikcetRes, error)
                FindLastCustomerTicket(pctx context.Context, customerId string) (*inventory.CustomerTikcetRes, error)
                AddCustomerTicket(pctx context.Context, req *inventory.AddCustomerTicketReq)
        }

        inventoryUseCase struct {
                inventoryRepo inventoryRepositories.InventoryRepositoryService
        }
)

func NewInventoryUseCase(inventoryRepo inventoryRepositories.InventoryRepositoryService) InventoryUseCaseService <span class="cov0" title="0">{
        return &amp;inventoryUseCase{inventoryRepo: inventoryRepo}
}</span>

func (u *inventoryUseCase) GetCustomerTicket(pctx context.Context, customerId string) ([]*inventory.CustomerTikcetRes, error) <span class="cov0" title="0">{

        results, err := u.inventoryRepo.GetCustomerTicket(pctx, strings.TrimPrefix(customerId, "customer:"))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: get movie show time failed %s", err.Error())
                return nil, err
        }</span>

        // _ = u.inventoryRepo.GetMovieDetails(pctx, results[0].MovieId)

        <span class="cov0" title="0">return results, nil</span>

}

func (u *inventoryUseCase) FindLastCustomerTicket(pctx context.Context, customerId string) (*inventory.CustomerTikcetRes, error) <span class="cov0" title="0">{

        // filter := bson.D{}
        // filterOptions := make([]*options.FindOneOptions, 0)

        findItemOption := make([]*options.FindOneOptions, 0)

        findItemOption = append(findItemOption, options.FindOne().SetSort(bson.D{{"created_at", -1}}))

        // filter = append(filter, options.FindOneOptions().WithFilter(filter))
        // filterOptions = append(filterOptions,bson.D{{"created_at":-1}})

        result, err := u.inventoryRepo.FindLastCustomerTicket(pctx, customerId, findItemOption)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: get movie show time failed %s", err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (u *inventoryUseCase) AddCustomerTicket(pctx context.Context, req *inventory.AddCustomerTicketReq) <span class="cov0" title="0">{

        insertId, err := u.inventoryRepo.AddCustomerTicket(pctx, &amp;inventory.CustomerTicket{
                CustomerId:    req.CustomerId,
                Ticket_Image:  req.TicketUrl,
                MovieId:       req.MovieId,
                MovieName:     req.MovieName,
                MovieDate:     req.MovieDate,
                MovieShowTime: req.MovieShowTime,
                PosterUrl:     req.PosterImage,
                OrderNumber:   req.OrderNumber,
                Created_At:    utils.GetLocaltime(),
                Price:         req.Price,
                Seat:          req.SeatNo,
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: AddCustomerTicket failed %s", err.Error())
        }</span>

        <span class="cov0" title="0">fmt.Println("insertID is", insertId)</span>

}
</pre>
		
		<pre class="file" id="file25" style="display: none">package middlewareHandlers

import (
        "net/http"
        "strings"

        "github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareUseCases"
        "github.com/labstack/echo/v4"
)

type (
        MiddlewareHandlerInterface interface {
                JwtAuthorize(next echo.HandlerFunc) echo.HandlerFunc
        }

        middlewareHandler struct {
                middlewareUsecase middlewareUseCases.MiddlewareUserCaseInterface
        }
)

func NewMiddlewareHandler(
        middlewareUsecase middlewareUseCases.MiddlewareUserCaseInterface,
) MiddlewareHandlerInterface <span class="cov0" title="0">{
        return &amp;middlewareHandler{middlewareUsecase: middlewareUsecase}
}</span>

func (h *middlewareHandler) JwtAuthorize(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                accessToken := strings.TrimPrefix(c.Request().Header.Get("Authorization"), "Bearer ")

                newCtx, err := h.middlewareUsecase.JwtAuthorize(c, accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, err.Error())
                }</span>

                <span class="cov0" title="0">return next(newCtx)</span>

        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package middlewareRepositories

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
)

type (
        IMiddlewareRepositoryService interface {
                AccessTokenSearch(pctx context.Context, cfg *config.Config, accessToken string) error
        }

        middlwareRepository struct {
        }
)

func NewMiddlewareRepository() IMiddlewareRepositoryService <span class="cov0" title="0">{
        return &amp;middlwareRepository{}
}</span>

func (r *middlwareRepository) AccessTokenSearch(pctx context.Context, cfg *config.Config, accessToken string) error <span class="cov0" title="0">{

        _, cancel := context.WithTimeout(pctx, time.Second*10)
        defer cancel()

        body := bytes.NewBuffer([]byte(nil))

        // Create a new POST request
        req, err := http.NewRequest("POST", fmt.Sprintf("http://"+cfg.AppUrl.CustomerUrl+"/user/find-access-token"), body)
        // req, err := http.NewRequest("POST", "http://localhost:8100/user/find-access-token", body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating request: %s", err.Error())
                return err
        }</span>

        // Add headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+accessToken)

        // Create an HTTP client and send the request
        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating client: %s", err.Error())
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        statusCode := resp.StatusCode
        if statusCode != 200 </span><span class="cov0" title="0">{
                return errors.New("errors: find access token failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package middlewareUseCases

import (
        "log"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareRepositories"
        "github.com/guatom999/TicketShop-Movie/pkg/jwtauth"
        "github.com/labstack/echo/v4"
)

type (
        MiddlewareUserCaseInterface interface {
                JwtAuthorize(c echo.Context, accessToken string) (echo.Context, error)
        }

        middlewareUseCase struct {
                middlewareRepository middlewareRepositories.IMiddlewareRepositoryService
                cfg                  *config.Config
        }
)

func NewMiddlwareUseCase(
        middlewareRepository middlewareRepositories.IMiddlewareRepositoryService,
        cfg *config.Config,
) MiddlewareUserCaseInterface <span class="cov0" title="0">{
        return &amp;middlewareUseCase{
                middlewareRepository: middlewareRepository,
                cfg:                  cfg,
        }
}</span>

func (u *middlewareUseCase) JwtAuthorize(c echo.Context, accessToken string) (echo.Context, error) <span class="cov0" title="0">{

        ctx := c.Request().Context()

        claims, err := jwtauth.ParseToken(u.cfg.Jwt.AccessSecretKey, accessToken)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Erorr is %s", err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := u.middlewareRepository.AccessTokenSearch(ctx, u.cfg, accessToken); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.Set("customer_id", claims.CustomerId)

        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package moviesHandlers

import (
        "context"
        "net/http"

        "github.com/guatom999/TicketShop-Movie/modules/movie"
        "github.com/guatom999/TicketShop-Movie/modules/movie/moviesUseCases"
        "github.com/labstack/echo/v4"
)

type (
        MoviesHandlerService interface {
                AddOneMovie(c echo.Context) error
                FindOneMovie(c echo.Context) error
                GetAllMovie(c echo.Context) error
                GetAllComingSoonMovie(c echo.Context) error
                TestReq(c echo.Context) error
                FindMovieShowTime(c echo.Context) error
                ReserveSeat(c echo.Context) error
                HealthCheck(c echo.Context) error
        }

        moviesHandler struct {
                moviesUseCase moviesUseCases.MoviesUseCaseService
        }
)

func NewMoviesHandler(moviesUseCase moviesUseCases.MoviesUseCaseService) MoviesHandlerService <span class="cov0" title="0">{
        return &amp;moviesHandler{moviesUseCase: moviesUseCase}
}</span>

func (h *moviesHandler) HealthCheck(c echo.Context) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, "status ok")
}</span>

func (h *moviesHandler) AddOneMovie(c echo.Context) error <span class="cov0" title="0">{
        ctx := context.Background()

        req := make([]*movie.AddMovieReq, 0)

        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.Logger().Error("Bind failed %s", err.Error())
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">if err := h.moviesUseCase.AddOneMovie(ctx, req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, "add movie success")</span>

}

func (h *moviesHandler) FindOneMovie(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        movieName := c.Param("movie_id")

        movie, err := h.moviesUseCase.FindOneMovie(ctx, movieName)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, movie)</span>

}

func (h *moviesHandler) GetAllMovie(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        result, err := h.moviesUseCase.FindAllMovie(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, result)</span>
}

func (h *moviesHandler) GetAllComingSoonMovie(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        result, err := h.moviesUseCase.FindComingSoonMovie(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, result)</span>
}

func (h *moviesHandler) FindMovieShowTime(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        movieName := c.Param("movieid")

        movies, err := h.moviesUseCase.FindMovieShowTime(ctx, movieName)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, movies)</span>
}

func (h *moviesHandler) ReserveSeat(c echo.Context) error <span class="cov0" title="0">{

        // ctx := context.Background()

        input := make([]*movie.ReserveDetailReq, 0)

        if err := c.Bind(&amp;input); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        // if err := h.moviesUseCase.ReserveSeat(ctx, input); err != nil {
        //         return c.JSON(http.StatusInternalServerError, err.Error())
        // }

        <span class="cov0" title="0">return c.JSON(http.StatusOK, "test success")</span>
}

func (h *moviesHandler) TestReq(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        result, err := h.moviesUseCase.TestReq(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, result)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, result)</span>
}

// func (h *moviesHandler)
</pre>
		
		<pre class="file" id="file29" style="display: none">package moviesHandlers

import (
        "context"
        "encoding/json"
        "fmt"
        "log"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/movie"
        "github.com/guatom999/TicketShop-Movie/modules/movie/moviesUseCases"
        "github.com/guatom999/TicketShop-Movie/pkg/queue"
)

type (
        MoviesQueueHandlerService interface {
                ReserveSeat()
                RollBackSeat()
        }

        moviesQueueHandler struct {
                cfg          *config.Config
                movieUseCase moviesUseCases.MoviesUseCaseService
        }
)

func NewMoviesQueueHandler(cfg *config.Config, movieUseCase moviesUseCases.MoviesUseCaseService) MoviesQueueHandlerService <span class="cov0" title="0">{
        return &amp;moviesQueueHandler{
                cfg:          cfg,
                movieUseCase: movieUseCase,
        }
}</span>

// func (h *moviesQueueHandler) MovieConsumer(pctx context.Context) *kafka.Reader {

//         reader := queue.KafkaReader()

//         return reader

// }

// func getConsumerMessage(consumer *kafka.Conn, consumerMessage chan kafka.Message) {

//         message, err := consumer.ReadMessage(10e3)
//         if err != nil {
//                 return
//         }

//         fmt.Println("message from consumer is", message)

//         consumerMessage &lt;- message

// }

func (h *moviesQueueHandler) ReserveSeat() <span class="cov0" title="0">{

        ctx := context.Background()

        data := new(movie.ReserveSeatReqTest)

        fmt.Println("h.cfg", h.cfg.Kafka.ApiKey)

        reader := queue.KafkaReader(h.cfg, "reserve-seat", "reserve-seat-req-group")
        defer reader.Close()

        for </span><span class="cov0" title="0">{

                message, err := reader.ReadMessage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error reading message: %s", err.Error())
                        break</span>
                }

                <span class="cov0" title="0">if string(message.Key) == "movie" </span><span class="cov0" title="0">{

                        if err := json.Unmarshal(message.Value, data); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error: Unmarshal error %s", err.Error())
                        }</span>

                        <span class="cov0" title="0">h.movieUseCase.ReserveSeat(ctx, &amp;movie.ReserveDetailReq{
                                MovieId: data.MovieId,
                                SeatNo:  data.Seat_Number,
                        })</span>
                }
        }
}

func (h *moviesQueueHandler) RollBackSeat() <span class="cov0" title="0">{

        ctx := context.Background()

        data := new(movie.RollBackReservedSeatReq)

        reader := queue.KafkaReader(h.cfg, "rollback", "roll-back-seat-req-group")
        defer reader.Close()

        for </span><span class="cov0" title="0">{
                message, err := reader.ReadMessage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error reading message: %s", err.Error())
                        break</span>
                }

                <span class="cov0" title="0">if string(message.Key) == "movie" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(message.Value, data); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error: Unmarshal error %s", err.Error())
                        }</span>

                        <span class="cov0" title="0">h.movieUseCase.RollbackReserveSeat(ctx, &amp;movie.ReserveDetailReq{
                                MovieId: data.MovieId,
                                SeatNo:  data.SeatNo,
                        })</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package moviesRepositories

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "math"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/movie"
        "github.com/guatom999/TicketShop-Movie/pkg/queue"
        "github.com/guatom999/TicketShop-Movie/utils"
        "github.com/redis/go-redis/v9"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"

        "github.com/segmentio/kafka-go"
)

type (
        MoviesRepositoryService interface {
                InsertMovie(pctx context.Context, req []*movie.Movie, movieRound int64) error
                FindOneMovie(pctx context.Context, movieId string) (*movie.MovieShowCase, error)
                FindAllMovie(pctx context.Context, filter any) ([]*movie.MovieData, error)
                FindComingSoonMovie(pctx context.Context, filter any) ([]*movie.MovieData, error)
                FindMovieShowtime(pctx context.Context, movieId string) ([]*movie.MovieShowTimeRes, error)
                GetOneMovieAvaliable(pctx context.Context, req *movie.ReserveDetailReq) (*movie.MovieAvaliable, error)
                UpdateSeatStatus(pctx context.Context, movidId string, req *movie.MovieAvaliable) error
                ReserveSeatRes(pctx context.Context, cfg *config.Config, req *movie.ReserveSeatRes) error
        }

        moviesrepository struct {
                db    *mongo.Client
                redis *redis.Client
        }
)

func NewMoviesrepository(db *mongo.Client, redis *redis.Client) MoviesRepositoryService <span class="cov0" title="0">{
        return &amp;moviesrepository{db: db, redis: redis}
}</span>

func MovieProducer(pctx context.Context, cfg *config.Config, topic string) *kafka.Conn <span class="cov0" title="0">{
        conn := queue.KafkaConn(cfg, topic)

        topicConfigs := kafka.TopicConfig{
                Topic:             string(topic),
                NumPartitions:     1,
                ReplicationFactor: 1,
        }

        // topicConfigs := make([]kafka.TopicConfig, 0)

        // if !queue.IsTopicIsAlreadyExits(conn, cfg.Kafka.Topic) {
        //         topicConfigs = append(topicConfigs, kafka.TopicConfig{
        //                 Topic:             topic,
        //                 NumPartitions:     1,
        //                 ReplicationFactor: 1,
        //         })
        // }

        if err := conn.CreateTopics(topicConfigs); err != nil </span><span class="cov0" title="0">{
                log.Printf("Erorr: Create Topic Failed %s", err.Error())
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">return conn</span>

}

func (r *moviesrepository) InsertMovie(pctx context.Context, req []*movie.Movie, movieRound int64) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie")

        toAddMovies := func() []any </span><span class="cov0" title="0">{
                datas := make([]any, 0)

                for i := 0; i &lt; len(req); i++ </span><span class="cov0" title="0">{
                        data := &amp;movie.Movie{
                                Title:           req[i].Title,
                                Description:     req[i].Description,
                                RunningTime:     req[i].RunningTime,
                                Price:           req[i].Price,
                                ImageUrl:        req[i].ImageUrl,
                                CreatedAt:       req[i].CreatedAt,
                                UpdatedAt:       req[i].UpdatedAt,
                                Category:        req[i].Category,
                                ReleaseAt:       req[i].ReleaseAt,
                                OutOfTheatersAt: req[i].OutOfTheatersAt,
                        }

                        datas = append(datas, data)
                }</span>

                <span class="cov0" title="0">return datas</span>

        }()

        <span class="cov0" title="0">result, err := col.InsertMany(ctx, toAddMovies)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Insert One Movie Failed")
                return errors.New("error: insert one movie failed")
        }</span>

        <span class="cov0" title="0">dayLength := req[len(req)-1].OutOfTheatersAt.YearDay() - req[0].ReleaseAt.YearDay() + 1

        lastInsertId := result.InsertedIDs[0].(primitive.ObjectID)

        col = db.Collection("movie_available")

        addMovieAvailable := func() []any </span><span class="cov0" title="0">{

                datas := make([]any, 0)

                for i := 0; i &lt; len(req); i++ </span><span class="cov0" title="0">{
                        for x := 0; x &lt; dayLength*int(movieRound); x++ </span><span class="cov0" title="0">{
                                data := movie.MovieAvaliable{
                                        Movie_Id:  result.InsertedIDs[i].(primitive.ObjectID).Hex(),
                                        Title:     req[i].Title,
                                        CreatedAt: utils.GetLocaltime(),
                                        UpdatedAt: func() time.Time </span><span class="cov0" title="0">{
                                                return utils.GetLocaltime()
                                        }</span>(),
                                        Showtime: utils.SetSpecificTime(req[i].ReleaseAt.Year(), req[i].ReleaseAt.Month(), req[i].ReleaseAt.Day()+int(math.Floor(float64(x)/float64(movieRound))), 10+(x%int(movieRound)), 30, 0),
                                        //Need Refactor
                                        SeatAvailable: []movie.SeatAvailable{
                                                {"A1": true},
                                                {"A2": true},
                                                {"A3": true},
                                                {"A4": true},
                                                {"A5": true},
                                                {"A6": true},
                                                {"A7": true},
                                                {"A8": true},
                                                {"A9": true},
                                                {"A10": true},
                                                {"A11": true},
                                                {"A12": true},
                                                {"B1": true},
                                                {"B2": true},
                                                {"B3": true},
                                                {"B4": true},
                                                {"B5": true},
                                                {"B6": true},
                                                {"B7": true},
                                                {"B8": true},
                                                {"B9": true},
                                                {"B10": true},
                                                {"B11": true},
                                                {"B12": true},
                                                {"C1": true},
                                                {"C2": true},
                                                {"C3": true},
                                                {"C4": true},
                                                {"C5": true},
                                                {"C6": true},
                                                {"C7": true},
                                                {"C8": true},
                                                {"C9": true},
                                                {"C10": true},
                                                {"C11": true},
                                                {"C12": true},
                                                {"D1": true},
                                                {"D2": true},
                                                {"D3": true},
                                                {"D4": true},
                                                {"D5": true},
                                                {"D6": true},
                                                {"D7": true},
                                                {"D8": true},
                                                {"D9": true},
                                                {"D10": true},
                                                {"D11": true},
                                                {"D12": true},
                                        },
                                }

                                <span class="cov0" title="0">datas = append(datas, data)</span>
                        }
                }

                <span class="cov0" title="0">return datas</span>

        }()

        <span class="cov0" title="0">_, err = col.InsertMany(ctx, addMovieAvailable)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Count Documents failed: %v", err)
                return errors.New("error: countDocuments failed")
        }</span>

        <span class="cov0" title="0">log.Println("first item id is", lastInsertId)

        return nil</span>

}

func (r *moviesrepository) FindOneMovie(pctx context.Context, movieId string) (*movie.MovieShowCase, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie")

        result := new(movie.Movie)

        if err := col.FindOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(movieId)}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: FindOne Movie Failed:%s", err.Error())
                return nil, errors.New("error: findone movie failed")
        }</span>

        <span class="cov0" title="0">return &amp;movie.MovieShowCase{
                Title:       result.Title,
                Description: result.Description,
                RunningTime: result.RunningTime,
                Price:       result.Price,
                ImageUrl:    result.ImageUrl,
        }, nil</span>
}

func (r *moviesrepository) FindAllMovie(pctx context.Context, filter any) ([]*movie.MovieData, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*30)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie")

        results := make([]*movie.MovieData, 0)

        value, err := r.redis.Get(ctx, "movies_list").Result()
        if err == nil </span><span class="cov0" title="0">{
                if err = json.Unmarshal([]byte(value), &amp;results); err == nil </span><span class="cov0" title="0">{
                        return results, nil
                }</span>
        }

        <span class="cov0" title="0">cursor, err := col.Find(ctx, filter)
        // cursor, err := col.Find(ctx, bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Find All Movie Failed: %s", err.Error())
                return make([]*movie.MovieData, 0), errors.New("error: find all item failed")
        }</span>

        <span class="cov0" title="0">for cursor.Next(ctx) </span><span class="cov0" title="0">{
                result := new(movie.Movie)
                if err := cursor.Decode(result); err != nil </span><span class="cov0" title="0">{
                        log.Println("Error: Find All Movie Failed:", err.Error())
                        return make([]*movie.MovieData, 0), errors.New("error: find all item failed")
                }</span>

                <span class="cov0" title="0">results = append(results, &amp;movie.MovieData{
                        MovieId:    result.Id.Hex(),
                        Title:      result.Title,
                        Release_At: utils.GetStringTime(result.ReleaseAt),
                        Price:      result.Price,
                        ImageUrl:   result.ImageUrl,
                })</span>
        }

        <span class="cov0" title="0">data, err := json.Marshal(results)
        if err != nil </span><span class="cov0" title="0">{
                return make([]*movie.MovieData, 0), errors.New("error: find all item failed")
        }</span>

        <span class="cov0" title="0">_, err = r.redis.Set(ctx, "movies_list", string(data), time.Second*30).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: set redis failed :%s", err.Error())
                // return make([]*movie.MovieData, 0), errors.New("error: set redis failed")
                return results, nil
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (r *moviesrepository) FindComingSoonMovie(pctx context.Context, filter any) ([]*movie.MovieData, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie")

        results := make([]*movie.MovieData, 0)

        value, err := r.redis.Get(ctx, "comingsoon_list").Result()
        if err == nil </span><span class="cov0" title="0">{
                if err = json.Unmarshal([]byte(value), &amp;results); err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: get comingsoon movies from redis failed :%s", err.Error())
                        return results, nil
                }</span>
        }

        <span class="cov0" title="0">cursor, err := col.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Find Coming SoonMovie Failed: %s", err.Error())
                return make([]*movie.MovieData, 0), nil
        }</span>

        <span class="cov0" title="0">for cursor.Next(ctx) </span><span class="cov0" title="0">{
                result := new(movie.Movie)
                if err := cursor.Decode(result); err != nil </span><span class="cov0" title="0">{
                        log.Println("Error: Find All Movie Failed:", err.Error())
                        return make([]*movie.MovieData, 0), errors.New("error: find all item failed")
                }</span>

                <span class="cov0" title="0">results = append(results, &amp;movie.MovieData{
                        MovieId:    result.Id.Hex(),
                        Title:      result.Title,
                        Release_At: utils.GetStringTime(result.ReleaseAt),
                        Price:      result.Price,
                        ImageUrl:   result.ImageUrl,
                })</span>

        }

        <span class="cov0" title="0">data, err := json.Marshal(results)
        if err != nil </span><span class="cov0" title="0">{
                return make([]*movie.MovieData, 0), errors.New("error: find comign soon movies failed")
        }</span>

        <span class="cov0" title="0">_, err = r.redis.Set(ctx, "comingsoon_list", string(data), time.Second*30).Result()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error: set redis failed", err.Error())
                // return make([]*movie.MovieData, 0), errors.New("error: set redis failed")
                return results, nil
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (r *moviesrepository) FindMovieShowtime(pctx context.Context, movieId string) ([]*movie.MovieShowTimeRes, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie_available")

        results := make([]*movie.MovieShowTimeRes, 0)

        log.Println(utils.GetLocaltime())

        cursor, err := col.Find(ctx, bson.M{"movie_id": movieId})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: FindOne Movie Failed:%s", err.Error())
                return nil, errors.New("error: findone movie failed")
        }</span>

        <span class="cov0" title="0">for cursor.Next(ctx) </span><span class="cov0" title="0">{
                result := new(movie.MovieAvaliable)
                if err := cursor.Decode(result); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error: Decode FineMovieShowtime failed:%s", err)
                        return make([]*movie.MovieShowTimeRes, 0), errors.New("error: find movie showtime failed")
                }</span>

                <span class="cov0" title="0">results = append(results, &amp;movie.MovieShowTimeRes{
                        Movie_id:      result.Id.Hex(),
                        Title:         result.Title,
                        ShowTime:      utils.GetStringTime(result.Showtime),
                        SeatAvailable: result.SeatAvailable,
                        IsComingSoon:  true,
                })</span>

        }

        <span class="cov0" title="0">return results, nil</span>
}

func (r *moviesrepository) GetOneMovieAvaliable(pctx context.Context, req *movie.ReserveDetailReq) (*movie.MovieAvaliable, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie_available")

        result := new(movie.MovieAvaliable)

        if err := col.FindOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(req.MovieId)}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Find Seat Status Failed:%s", err.Error())
                return nil, errors.New("error: find seat status failed")
        }</span>

        <span class="cov0" title="0">return result, nil</span>

        // for _, reserveSeatNo := range req.SeatNo {
        //         for x, seatAvailable := range result.SeatAvailable {
        //                 if _, ok := seatAvailable[reserveSeatNo]; ok {
        //                         result.SeatAvailable[x][reserveSeatNo] = false
        //                         break
        //                 } else if x == (len(result.SeatAvailable) - 1) {
        //                         log.Println("error:no seat match")
        //                         return errors.New("error: no seat match")
        //                 }
        //         }
        // }

        // updateResult, err := col.UpdateOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(req.MovieId)}, bson.M{"$set": result})
        // if err != nil {
        //         log.Printf("Error: Update Seat Status Failed %v", err)
        //         return errors.New("error: update seat status failed")
        // }

        // log.Printf("update status is :%v", updateResult)

        // return nil

}

func (r *moviesrepository) UpdateSeatStatus(pctx context.Context, movidId string, req *movie.MovieAvaliable) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie_available")

        _, err := col.UpdateOne(ctx, bson.M{"_id": utils.ConvertStringToObjectId(movidId)}, bson.M{"$set": req})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Update Seat Status Failed %v", err)
                return errors.New("error: update seat status failed")
        }</span>

        // log.Printf("update status is :%v", updateResult)

        <span class="cov0" title="0">return nil</span>
}

func (r *moviesrepository) ReserveSeatRes(pctx context.Context, cfg *config.Config, req *movie.ReserveSeatRes) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        conn := MovieProducer(ctx, cfg, "reserve-seat-res")

        message := kafka.Message{
                Key:   []byte("payment"),
                Value: utils.EncodeMessage(req),
        }

        // conn.SetWriteDeadline(time.Now().Add(20 * time.Second))
        _, err := conn.WriteMessages(message)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to write messages:", err)
                return errors.New("error: failed to send message")
        }</span>

        <span class="cov0" title="0">if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to close writer:", err)
                return errors.New("error: failed to close broker")
        }</span>

        <span class="cov0" title="0">fmt.Println("Send Message Success")

        return nil</span>
}

// func (r *moviesrepository) ReserveSeatRes(pctx context.Context, cfg *config.Config, req *movie.RollBackReserveSeatRes) error {

//         ctx, cancel := context.WithTimeout(pctx, time.Second*20)
//         defer cancel()

//         conn := MovieProducer(ctx, cfg, "roll-back-res")

//         message := kafka.Message{
//                 Value: utils.EncodeMessage(req),
//         }

//         conn.SetReadDeadline(time.Now().Add(10 * time.Second))
//         _, err := conn.WriteMessages(message)

//         if err != nil {
//                 log.Fatal("failed to write messages:", err)
//                 return errors.New("error: failed to send message")
//         }

//         if err := conn.Close(); err != nil {
//                 log.Fatal("failed to close writer:", err)
//                 return errors.New("error: failed to close broker")
//         }

//         fmt.Println("Send Message Success")

//         return nil
// }

// func (r *moviesrepository) FindManyMovies(pctx context.Context, filter primitive.ObjectID, opts []*options.FindOptions) ([]*movie.MovieData, error) {

//         ctx, cancel := context.WithTimeout(pctx, time.Second*20)
//         defer cancel()

//         db := r.db.Database("movie_db")
//         col := db.Collection("movie")

//         cur, err := col.Find(ctx, filter, opts...)
//         if err != nil {
//                 log.Printf("Error: Find All Movie Failed: %s", err.Error())
//                 return make([]*movie.MovieData, 0), errors.New("error: find many item failed")
//         }

//         results := make([]*movie.MovieData, 0)

//         for cur.Next(ctx) {
//                 result := new(movie.Movie)
//                 if err := cur.Decode(result); err != nil {
//                         log.Printf("Error: Find Many Movies Failed:%s", err.Error())
//                         return make([]*movie.MovieData, 0), errors.New("error: find many movie failed")
//                 }

//                 results = append(results, &amp;movie.MovieData{
//                         MovieId:   result.Id.Hex(),
//                         Title:     result.Title,
//                         Price:     result.Price,
//                         ImageUrl:  result.ImageUrl,
//                         Avaliable: result.Avaliable,
//                 })

//         }

//         return results, nil
// }

func (r *moviesrepository) InsertNews(pctx context.Context, req *movie.AddNewsReq) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie_news")

        _, err := col.InsertOne(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Insert Movie News Failed:%s", err.Error())
                return errors.New("error: insert movie news failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *moviesrepository) InsertPromotions(pctx context.Context, req *movie.AddPromotionsReq) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("movie_db")
        col := db.Collection("movie_promotions")

        _, err := col.InsertOne(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Insert Movie News Failed:%s", err.Error())
                return errors.New("error: insert movie news failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package moviesRepositories

import (
        "context"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/movie"
        "github.com/stretchr/testify/mock"
)

type (
        MovieRepositoryMock struct {
                mock.Mock
        }
)

func NewMovieRepoMock() MoviesRepositoryService <span class="cov0" title="0">{
        return &amp;MovieRepositoryMock{}
}</span>

func (m *MovieRepositoryMock) InsertMovie(pctx context.Context, req []*movie.Movie, movieRound int64) error <span class="cov0" title="0">{
        args := m.Called(pctx, req, movieRound)
        return args.Error(0)
}</span>
func (m *MovieRepositoryMock) FindOneMovie(pctx context.Context, movieId string) (*movie.MovieShowCase, error) <span class="cov0" title="0">{
        args := m.Called(pctx, movieId)
        return args.Get(0).(*movie.MovieShowCase), args.Error(1)
}</span>
func (m *MovieRepositoryMock) FindAllMovie(pctx context.Context, filter any) ([]*movie.MovieData, error) <span class="cov0" title="0">{
        args := m.Called(pctx, filter)
        return args.Get(0).([]*movie.MovieData), args.Error(1)
}</span>
func (m *MovieRepositoryMock) FindComingSoonMovie(pctx context.Context, filter any) ([]*movie.MovieData, error) <span class="cov0" title="0">{
        args := m.Called(pctx, filter)
        return args.Get(0).([]*movie.MovieData), args.Error(1)
}</span>
func (m *MovieRepositoryMock) FindMovieShowtime(pctx context.Context, movieId string) ([]*movie.MovieShowTimeRes, error) <span class="cov0" title="0">{
        args := m.Called(pctx, movieId)
        return args.Get(0).([]*movie.MovieShowTimeRes), args.Error(1)
}</span>
func (m *MovieRepositoryMock) GetOneMovieAvaliable(pctx context.Context, req *movie.ReserveDetailReq) (*movie.MovieAvaliable, error) <span class="cov0" title="0">{
        args := m.Called(pctx, req)
        return args.Get(0).(*movie.MovieAvaliable), args.Error(1)
}</span>
func (m *MovieRepositoryMock) UpdateSeatStatus(pctx context.Context, movidId string, req *movie.MovieAvaliable) error <span class="cov0" title="0">{
        args := m.Called(pctx, movidId, req)
        return args.Error(0)
}</span>
func (m *MovieRepositoryMock) ReserveSeatRes(pctx context.Context, cfg *config.Config, req *movie.ReserveSeatRes) error <span class="cov0" title="0">{
        args := m.Called(pctx, cfg, req)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package moviesUseCases

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/movie"
        "github.com/guatom999/TicketShop-Movie/modules/movie/moviesRepositories"
        "github.com/guatom999/TicketShop-Movie/pkg/rest"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson"
)

type (
        MoviesUseCaseService interface {
                AddOneMovie(pctx context.Context, req []*movie.AddMovieReq) error
                FindAllMovie(pctx context.Context) ([]*movie.MovieData, error)
                FindComingSoonMovie(pctx context.Context) ([]*movie.MovieData, error)
                TestReq(pctx context.Context) (string, error)
                FindOneMovie(pctx context.Context, movieId string) (*movie.MovieShowCase, error)
                FindMovieShowTime(pctx context.Context, title string) ([]*movie.MovieShowTimeRes, error)
                ReserveSeat(pctx context.Context, req *movie.ReserveDetailReq) error
                RollbackReserveSeat(pctx context.Context, req *movie.ReserveDetailReq) error
        }

        moviesUseCase struct {
                cfg        *config.Config
                moviesRepo moviesRepositories.MoviesRepositoryService
        }
)

func NewmoviesUseCase(cfg *config.Config, moviesRepo moviesRepositories.MoviesRepositoryService) MoviesUseCaseService <span class="cov0" title="0">{
        return &amp;moviesUseCase{cfg: cfg, moviesRepo: moviesRepo}
}</span>

func (u *moviesUseCase) AddOneMovie(pctx context.Context, req []*movie.AddMovieReq) error <span class="cov0" title="0">{

        movieEntity := make([]*movie.Movie, 0)

        for i := 0; i &lt; len(req); i++ </span><span class="cov0" title="0">{
                movieEntity = append(movieEntity, &amp;movie.Movie{
                        Title:           req[i].Title,
                        Description:     req[i].Description,
                        RunningTime:     req[i].RunningTime,
                        Price:           req[i].Price,
                        ImageUrl:        req[i].ImageUrl,
                        CreatedAt:       time.Now(),
                        UpdatedAt:       time.Now(),
                        Category:        "RomCom",
                        ReleaseAt:       utils.ConvertStringDateToTime(req[i].ReleaseAt),
                        OutOfTheatersAt: utils.ConvertStringDateToTime(req[i].OutOfTheatersAt),
                })
        }</span>

        <span class="cov0" title="0">if err := u.moviesRepo.InsertMovie(pctx, movieEntity, req[0].MoviesRoundPerDay); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FindWithMoreCondition
func (u *moviesUseCase) FindOneMovie(pctx context.Context, movieId string) (*movie.MovieShowCase, error) <span class="cov0" title="0">{

        result, err := u.moviesRepo.FindOneMovie(pctx, movieId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // return &amp;movie.MovieShowCase{
        //         Title:    result.Title,
        //         Price:    result.Price,
        //         ImageUrl: result.ImageUrl,
        // }, nil

        <span class="cov0" title="0">return result, nil</span>

}

func (u *moviesUseCase) FindAllMovie(pctx context.Context) ([]*movie.MovieData, error) <span class="cov0" title="0">{

        filter := bson.D{}

        filter = append(filter, bson.E{"out_of_theaters_at", bson.D{{"$gt", utils.GetLocaltime()}}}, bson.E{"release_at", bson.D{{"$lt", utils.GetLocaltime()}}})

        result, err := u.moviesRepo.FindAllMovie(pctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return make([]*movie.MovieData, 0), nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (u *moviesUseCase) FindComingSoonMovie(pctx context.Context) ([]*movie.MovieData, error) <span class="cov0" title="0">{

        filter := bson.D{}

        filter = append(filter, bson.E{"release_at", bson.D{{"$gt", utils.GetLocaltime()}}})

        results, err := u.moviesRepo.FindComingSoonMovie(pctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return results, err
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (u *moviesUseCase) FindManyMovie(pctx context.Context, basePaginateUrl string) error <span class="cov0" title="0">{

        // findItemsFilter := bson.D{}
        // findItemOption := make([]*options.FindOptions, 0)

        // countItemsFilter := bson.D{}

        // // Find many item filter
        // if req.Start != "" {
        //         req.Start = strings.TrimPrefix(req.Start, "item:")
        //         findItemsFilter = append(findItemsFilter, bson.E{"_id", bson.D{{"$gt", utils.ConvertToObjectId(req.Start)}}})
        // }

        // if req.Title != "" {
        //         findItemsFilter = append(findItemsFilter, bson.E{"title", primitive.Regex{Pattern: req.Title, Options: "i"}})
        //         countItemsFilter = append(countItemsFilter, bson.E{"title", primitive.Regex{Pattern: req.Title, Options: "i"}})
        // }

        // findItemsFilter = append(findItemsFilter, bson.E{"usage_status", true})
        // countItemsFilter = append(countItemsFilter, bson.E{"usage_status", true})

        // // options
        // findItemOption = append(findItemOption, options.Find().SetSort(bson.D{{"_id", 1}}))
        // findItemOption = append(findItemOption, options.Find().SetLimit(int64(req.Limit)))

        // results, err := u.itemRepo.FindManyItems(pctx, findItemsFilter, findItemOption)
        // if err != nil {
        //         return nil, err
        // }

        // total, err := u.itemRepo.CountItems(pctx, countItemsFilter)
        // if err != nil {
        //         return nil, err
        // }

        // if len(results) == 0 {
        //         return &amp;models.PaginateRes{
        //                 Data:  make([]*item.ItemShowCase, 0),
        //                 Total: total,
        //                 Limit: req.Limit,
        //                 First: models.FirstPaginate{
        //                         Href: fmt.Sprintf("%s?limit=%d&amp;title=%s", req.Limit, basePaginateUrl, req.Title),
        //                 },
        //                 Next: models.NextPaginate{
        //                         Start: "",
        //                         Href:  "",
        //                 },
        //         }, nil
        // }

        // return &amp;models.PaginateRes{
        //         Data:  results,
        //         Total: total,
        //         Limit: req.Limit,
        //         First: models.FirstPaginate{
        //                 Href: fmt.Sprintf("%s?limit=%d&amp;title=%s", req.Limit, basePaginateUrl, req.Title),
        //         },
        //         Next: models.NextPaginate{
        //                 Start: results[len(results)-1].ItemId,
        //                 Href:  fmt.Sprintf("%s?limit=%d&amp;title=%s&amp;start=%s", basePaginateUrl, req.Limit, req.Title, results[len(results)-1].ItemId),
        //         },
        // }, nil

        return nil
}</span>

func (u *moviesUseCase) FindMovieShowTime(pctx context.Context, title string) ([]*movie.MovieShowTimeRes, error) <span class="cov0" title="0">{

        movies, err := u.moviesRepo.FindMovieShowtime(pctx, title)
        if err != nil </span><span class="cov0" title="0">{
                return make([]*movie.MovieShowTimeRes, 0), err
        }</span>

        <span class="cov0" title="0">return movies, nil</span>
}

func (u *moviesUseCase) ReserveSeat(pctx context.Context, req *movie.ReserveDetailReq) error <span class="cov0" title="0">{

        result, err := u.moviesRepo.GetOneMovieAvaliable(pctx, req)
        if err != nil </span><span class="cov0" title="0">{
                // u.moviesRepo.RollbackSeatStatusRes(pctx, result)
                u.moviesRepo.ReserveSeatRes(pctx, u.cfg, &amp;movie.ReserveSeatRes{
                        MovieId:     req.MovieId,
                        Seat_Number: req.SeatNo,
                        Error:       err.Error(),
                })
                return err
        }</span>

        <span class="cov0" title="0">for _, reserveSeatNo := range req.SeatNo </span><span class="cov0" title="0">{
                for x, seatAvailable := range result.SeatAvailable </span><span class="cov0" title="0">{
                        if _, ok := seatAvailable[reserveSeatNo]; ok </span><span class="cov0" title="0">{
                                result.SeatAvailable[x][reserveSeatNo] = false
                                break</span>
                        } else<span class="cov0" title="0"> if x == (len(result.SeatAvailable) - 1) </span><span class="cov0" title="0">{

                                u.moviesRepo.ReserveSeatRes(pctx, u.cfg, &amp;movie.ReserveSeatRes{
                                        MovieId:     req.MovieId,
                                        Seat_Number: req.SeatNo,
                                        Error:       errors.New("error: no seat match").Error(),
                                })
                                return errors.New("error: no seat match")
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := u.moviesRepo.UpdateSeatStatus(pctx, req.MovieId, result); err != nil </span><span class="cov0" title="0">{
                u.moviesRepo.ReserveSeatRes(pctx, u.cfg, &amp;movie.ReserveSeatRes{
                        MovieId:     req.MovieId,
                        Seat_Number: req.SeatNo,
                        Error:       err.Error(),
                })
                return err
        }</span>

        <span class="cov0" title="0">u.moviesRepo.ReserveSeatRes(pctx, u.cfg, &amp;movie.ReserveSeatRes{
                MovieId:     req.MovieId,
                Seat_Number: req.SeatNo,
                Error:       "",
        })

        return nil</span>
}

func (u *moviesUseCase) RollbackReserveSeat(pctx context.Context, req *movie.ReserveDetailReq) error <span class="cov0" title="0">{

        result, err := u.moviesRepo.GetOneMovieAvaliable(pctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, reserveSeatNo := range req.SeatNo </span><span class="cov0" title="0">{
                for x, seatAvailable := range result.SeatAvailable </span><span class="cov0" title="0">{
                        if _, ok := seatAvailable[reserveSeatNo]; ok </span><span class="cov0" title="0">{
                                result.SeatAvailable[x][reserveSeatNo] = true
                                break</span>
                        } else<span class="cov0" title="0"> if x == (len(result.SeatAvailable) - 1) </span><span class="cov0" title="0">{

                                log.Println("error:no seat match")
                                return errors.New("error: no seat match")
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := u.moviesRepo.UpdateSeatStatus(pctx, req.MovieId, result); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u *moviesUseCase) TestReq(pctx context.Context) (string, error) <span class="cov0" title="0">{

        url := "http://localhost:8099/booking/test"

        res, err := rest.Request(url)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Error is : %s", err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">fmt.Println("Response body:", res)

        return res, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package paymentHandler

import (
        "context"
        "net/http"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/payment"
        "github.com/guatom999/TicketShop-Movie/modules/payment/paymentUseCases"
        "github.com/labstack/echo/v4"
)

type (
        PaymentHandlerService interface {
                BuyTicket(c echo.Context) error
                TestUpload(c echo.Context) error
                HealthCheck(c echo.Context) error
                // CheckOutWithCreditCard(c echo.Context) error
        }

        paymentHandler struct {
                paymentUseCase paymentUseCases.PaymentUseCaseService
                cfg            *config.Config
        }
)

func NewPaymentHanlder(cfg *config.Config, paymentUseCase paymentUseCases.PaymentUseCaseService) PaymentHandlerService <span class="cov0" title="0">{
        return &amp;paymentHandler{
                cfg:            cfg,
                paymentUseCase: paymentUseCase,
        }
}</span>

func (h *paymentHandler) HealthCheck(c echo.Context) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, "status ok")
}</span>

func (h *paymentHandler) BuyTicket(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        req := new(payment.MovieBuyReq)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">result, err := h.paymentUseCase.BuyTicket(ctx, h.cfg, req)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err)
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, result)</span>
}

func (h *paymentHandler) TestUpload(c echo.Context) error <span class="cov0" title="0">{

        // file, err := c.FormFile("image")
        // if err != nil {
        //         return c.JSON(http.StatusBadRequest, err.Error())
        // }

        // blobfile, err := file.Open()
        // if err != nil {
        //         return c.JSON(http.StatusBadRequest, err.Error())
        // }

        // if err := h.paymentUseCase.UploadFileTest(blobfile, ""); err != nil {
        //         return c.JSON(http.StatusInternalServerError, err)
        // }

        return c.JSON(http.StatusOK, "test")
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package paymentRepositories

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/model"
        "github.com/guatom999/TicketShop-Movie/modules/payment"
        "github.com/guatom999/TicketShop-Movie/pkg/queue"
        "github.com/guatom999/TicketShop-Movie/utils"
        "github.com/labstack/gommon/log"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "github.com/segmentio/kafka-go"
)

type (
        PaymentRepositoryService interface {
                // ReserveSeat(pctx context.Context) error
                ReserveSeat(pctx context.Context, cfg *config.Config, req *payment.ReserveSeatReq) error
                AddTicketToCustomer(pctx context.Context, cfg *config.Config, req *payment.AddCustomerTicket) error
                GetOffset(pctx context.Context) (int64, error)
                UpsertOfset(pctx context.Context, offset int64) error
                RollBackReserveSeat(pctx context.Context, cfg *config.Config, req *payment.RollBackReservedSeatReq) error
        }

        paymentRepository struct {
                // cfg *config.Config
                db *mongo.Client
        }
)

func NewPaymentRepository(db *mongo.Client) PaymentRepositoryService <span class="cov0" title="0">{
        return &amp;paymentRepository{db: db}
}</span>

func PaymentProducer(pctx context.Context, cfg *config.Config, topic string) *kafka.Conn <span class="cov0" title="0">{
        conn := queue.KafkaConn(cfg, topic)

        // topicConfigs := []kafka.TopicConfig{
        //         {
        //                 Topic:             "buy",
        //                 NumPartitions:     1,
        //                 ReplicationFactor: 1,
        //         },
        //         {
        //                 Topic:             "rollback",
        //                 NumPartitions:     1,
        //                 ReplicationFactor: 1,
        //         },
        // }

        topicConfigs := kafka.TopicConfig{
                Topic:             topic,
                NumPartitions:     1,
                ReplicationFactor: 1,
        }

        // topicConfigs := make([]kafka.TopicConfig, 0)

        // if !queue.IsTopicIsAlreadyExits(conn, cfg.Kafka.Topic) {
        //         topicConfigs = append(topicConfigs, kafka.TopicConfig{
        //                 Topic:             topic,
        //                 NumPartitions:     1,
        //                 ReplicationFactor: 1,
        //         })
        // }

        if err := conn.CreateTopics(topicConfigs); err != nil </span><span class="cov0" title="0">{
                log.Printf("Erorr: Create Topic Failed %s", err.Error())
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">return conn</span>

}

func (r *paymentRepository) GetOffset(pctx context.Context) (int64, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*30)
        defer cancel()

        db := r.db.Database("payment_db")
        col := db.Collection("payment_queue")

        result := new(model.KafKaOffset)

        if err := col.FindOne(ctx, bson.M{}).Decode(result); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: GetOffset  failed: %s", err.Error())
                return -1, errors.New("error: getoffset failed")
        }</span>

        <span class="cov0" title="0">return 0, nil</span>
}

func (r *paymentRepository) UpsertOfset(pctx context.Context, offset int64) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*30)
        defer cancel()

        db := r.db.Database("payment_db")
        col := db.Collection("payment_queue")

        result, err := col.UpdateOne(ctx, bson.M{}, bson.M{"$set": bson.M{"offset": offset}}, options.Update().SetUpsert(true))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Update Upsert Offset Failed %s", err.Error())
                return errors.New("error: update offset failed")
        }</span>

        <span class="cov0" title="0">fmt.Println("Result is", result)

        return nil</span>

}

func (r *paymentRepository) ReserveSeat(pctx context.Context, cfg *config.Config, req *payment.ReserveSeatReq) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        // conn := PaymentProducer(ctx, cfg, "buy-ticket")
        conn := PaymentProducer(ctx, cfg, "reserve-seat")

        message := kafka.Message{
                Key:   []byte("movie"),
                Value: utils.EncodeMessage(req),
        }

        conn.SetReadDeadline(time.Now().Add(10 * time.Second))
        _, err := conn.WriteMessages(message)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to write messages:", err)
                return errors.New("error: failed to send message")
        }</span>

        // Close connection
        <span class="cov0" title="0">if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to close writer:", err)
                return errors.New("error: failed to close broker")
        }</span>

        <span class="cov0" title="0">fmt.Println("Send Message Success")

        return nil</span>
}

func (r *paymentRepository) RollBackReserveSeat(pctx context.Context, cfg *config.Config, req *payment.RollBackReservedSeatReq) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        conn := PaymentProducer(ctx, cfg, "rollback")

        message := kafka.Message{
                Key:   []byte("movie"),
                Value: utils.EncodeMessage(req),
        }

        conn.SetReadDeadline(time.Now().Add(time.Second * 20))
        _, err := conn.WriteMessages(message)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error writing message: %v", err)
                return errors.New("error: write message failed")
        }</span>

        <span class="cov0" title="0">if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error Failed to close queue: %v", err)
                return errors.New("error: failed to close message queue")
        }</span>
        <span class="cov0" title="0">fmt.Println("Send Message Success")

        return nil</span>
}

func (r *paymentRepository) AddTicketToCustomer(pctx context.Context, cfg *config.Config, req *payment.AddCustomerTicket) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        conn := PaymentProducer(ctx, cfg, "add-ticket")

        message := kafka.Message{
                Value: utils.EncodeMessage(req),
        }

        conn.SetReadDeadline(time.Now().Add(time.Second * 20))
        _, err := conn.WriteMessages(message)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error writing message: %v", err)
                return errors.New("error: write message failed")
        }</span>

        <span class="cov0" title="0">if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error Failed to close queue: %v", err)
                return errors.New("error: failed to close messagq queue")
        }</span>
        <span class="cov0" title="0">fmt.Println("Send Message Success")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package paymentUseCases

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/payment"
        "github.com/guatom999/TicketShop-Movie/modules/payment/paymentRepositories"
        "github.com/guatom999/TicketShop-Movie/pkg/queue"
        "github.com/guatom999/TicketShop-Movie/utils"
        "github.com/omise/omise-go"
        "github.com/omise/omise-go/operations"
)

type (
        PaymentUseCaseService interface {
                BuyTicket(pctx context.Context, cfg *config.Config, req *payment.MovieBuyReq) (*payment.BuyticketRes, error)
                CheckOutWithCreditCard(req *payment.CheckOutWithCreditCard) error
                // UploadFileTest(file multipart.File, object string) error
                // BuyTicketConsumer(pctx context.Context, topic string, resCh chan&lt;- *payment.RollBackReserveSeatRes)
        }

        paymentUseCase struct {
                paymentRepo paymentRepositories.PaymentRepositoryService
                cfg         *config.Config
                opnClient   *omise.Client
                bucketName  string
                uploadPath  string
                // cl          *storage.Client
        }

        UploadResponse struct {
                Filename string `json:"filename"`
                URL      string `json:"url"`
        }
)

func NewPaymentUseCase(
        paymentRepo paymentRepositories.PaymentRepositoryService,
        cfg *config.Config,
        opnClient *omise.Client,
        // cli *storage.Client, close client for a while
) PaymentUseCaseService <span class="cov0" title="0">{

        return &amp;paymentUseCase{
                paymentRepo: paymentRepo,
                cfg:         cfg,
                opnClient:   opnClient,
                bucketName:  "ticket-shop-bucket",
                uploadPath:  "ticket-image/",
                // cl:          cli,
        }
}</span>

func (u *paymentUseCase) CheckOutWithCreditCard(req *payment.CheckOutWithCreditCard) error <span class="cov0" title="0">{

        charge, createCharge := &amp;omise.Charge{}, &amp;operations.CreateCharge{
                Amount:   req.Price,
                Currency: "thb",
                Card:     req.Token,
        }
        if err := u.opnClient.Do(charge, createCharge); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("omise clinet failed  %s", err.Error())
                return errors.New("error: omise client failed")
        }</span>

        <span class="cov0" title="0">log.Printf("charge: %s  amount: %s %d\n", charge.ID, charge.Currency, charge.Amount)

        return nil</span>
}

// func PaymentConsumer(pctx context.Context, cfg *config.Config, topic string) *kafka.Conn {
//         conn := queue.KafkaConn(cfg, topic)

//         topicConfigs := kafka.TopicConfig{
//                 Topic:             topic,
//                 NumPartitions:     1,
//                 ReplicationFactor: 1,
//         }

//         if err := conn.CreateTopics(topicConfigs); err != nil {
//                 log.Printf("Erorr: Create Topic Failed %s", err.Error())
//                 panic(err.Error())
//         }

//         return conn

// }

func (u *paymentUseCase) BuyTicketConsumer(pctx context.Context, cfg *config.Config, groupId string, topic string, key string, resCh chan&lt;- *payment.RollBackReserveSeatRes) <span class="cov0" title="0">{
        reader := queue.KafkaReader(u.cfg, topic, groupId)
        defer reader.Close()

        data := new(payment.RollBackReserveSeatRes)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-pctx.Done():<span class="cov0" title="0">
                        log.Println("BuyTicketConsumer context cancelled")
                        close(resCh)
                        return</span>
                default:<span class="cov0" title="0">
                        msg, err := reader.ReadMessage(pctx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error reading message: %s", err.Error())
                                close(resCh)
                                return
                        }</span>

                        <span class="cov0" title="0">if string(msg.Key) == key </span><span class="cov0" title="0">{
                                fmt.Println("============================&gt;")
                                if err := json.Unmarshal(msg.Value, data); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error: Unmarshal error %s", err.Error())
                                }</span>

                                <span class="cov0" title="0">resCh &lt;- data
                                close(resCh)
                                return</span>
                        }
                }
        }
}

func (u *paymentUseCase) BuyTicket(pctx context.Context, cfg *config.Config, req *payment.MovieBuyReq) (*payment.BuyticketRes, error) <span class="cov0" title="0">{

        _, cancel := context.WithTimeout(context.Background(), time.Second*30)
        defer cancel()

        stage1 := new(payment.RollBackReserveSeatRes)

        resCh := make(chan *payment.RollBackReserveSeatRes)

        go u.BuyTicketConsumer(pctx, cfg, "reserve-seat-res-group", "reserve-seat-res", "payment", resCh)

        req.CustomerId = strings.TrimPrefix(req.CustomerId, "customer:")

        fmt.Println("req.PosterImage is", req.PosterImage)

        if err := u.paymentRepo.ReserveSeat(pctx, cfg, &amp;payment.ReserveSeatReq{
                MovieName: req.MovieName,
                MovieId:   req.MovieId,
                SeatNo:    req.SeatNo,
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">select </span>{
        case res := &lt;-resCh:<span class="cov0" title="0">
                if res != nil </span><span class="cov0" title="0">{
                        stage1 = &amp;payment.RollBackReserveSeatRes{
                                MovieId:     res.MovieId,
                                Seat_Number: res.Seat_Number,
                                Error:       res.Error,
                        }
                }</span>
        case &lt;-time.After(time.Second * 10):<span class="cov0" title="0">
                u.paymentRepo.RollBackReserveSeat(pctx, cfg, &amp;payment.RollBackReservedSeatReq{
                        MovieId: req.MovieId,
                        SeatNo:  req.SeatNo,
                })
                fmt.Println("Timeout waiting for rollback response")
                return nil, errors.New("timeout waiting for rollback response")</span>
        }

        <span class="cov0" title="0">if stage1.Error != "" </span><span class="cov0" title="0">{
                fmt.Println("stage1.Error", stage1.Error)
                u.paymentRepo.RollBackReserveSeat(pctx, cfg, &amp;payment.RollBackReservedSeatReq{
                        MovieId: req.MovieId,
                        SeatNo:  req.SeatNo,
                })

                return nil, errors.New("error: failed to reserve seat")
        }</span>

        <span class="cov0" title="0">if err := u.CheckOutWithCreditCard(&amp;payment.CheckOutWithCreditCard{Token: req.Token, Price: req.Price}); err != nil </span><span class="cov0" title="0">{
                u.paymentRepo.RollBackReserveSeat(pctx, cfg, &amp;payment.RollBackReservedSeatReq{
                        MovieId: req.MovieId,
                        SeatNo:  req.SeatNo,
                })
                return nil, err
        }</span>

        // var png []byte
        // var fileUrl string
        // reqQrCode := utils.GenQRCode(int(req.Price))

        // png, err := qrcode.Encode(reqQrCode, qrcode.Medium, 256)
        // if err != nil {
        //         log.Printf("Error: Failed to create qrcode file: %s", err.Error())
        //         // return nil, errors.New("error: failed to create qrcode file")
        //         fileUrl = `https://i1.sndcdn.com/artworks-x8zI2HVC2pnkK7F5-4xKLyA-t1080x1080.jpg`
        // }

        // destination := fmt.Sprintf(u.uploadPath + utils.RandFileName())

        // fileUrl, err = gcpfile.UploadFile(u.cfg, u.cl, pctx, destination, png)
        // if err != nil {
        //         log.Printf("Error: Upload file failed: %s", err.Error())
        //         fileUrl = `https://i1.sndcdn.com/artworks-x8zI2HVC2pnkK7F5-4xKLyA-t1080x1080.jpg`
        //         // return nil, errors.New("error: failed to upload file")
        // }
        <span class="cov0" title="0">fileUrl := string("https://storage.googleapis.com/ticket-shop-bucket/ticket-image/2409ec_1739993038586")

        orderNumber := utils.RandomString()

        if err := u.paymentRepo.AddTicketToCustomer(pctx, cfg, &amp;payment.AddCustomerTicket{
                CustomerId:    req.CustomerId,
                OrderNumber:   orderNumber,
                Date:          req.Date,
                MovieName:     req.MovieName,
                MovieId:       req.MovieId,
                MovieDate:     req.MovieDate,
                MovieShowTime: req.MovieShowTime,
                PosterImage:   req.PosterImage,
                TicketUrl:     fileUrl,
                SeatNo:        req.SeatNo,
                Quantity:      req.Quantity,
                Price:         req.Price,
        }); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: Failed to add ticket %s", err.Error())
                return nil, errors.New("error: failed to add ticket")
        }</span>

        <span class="cov0" title="0">return &amp;payment.BuyticketRes{
                TransactionId: orderNumber,
                Url:           fileUrl,
        }, nil</span>
}

// func (c *paymentUseCase) UploadFileTest(file multipart.File, object string) error {
//         ctx := context.Background()

//         ctx, cancel := context.WithTimeout(ctx, time.Second*50)
//         defer cancel()

//         var png []byte
//         png, err := qrcode.Encode("https://photos.app.goo.gl/pkN35vFQhc6DRXqQ6", qrcode.Medium, 256)
//         if err != nil {
//                 log.Printf("Error: Failed to create qrcode file:%s", err.Error())
//                 return errors.New("error:failed to create qrcode file")
//         }

//         // buff := bytes.NewBuffer(png)

//         gcpfile.UploadFile(c.cfg, c.cl, ctx, c.uploadPath+object, png)

//         // Upload an object with storage.Writer.

//         // wc := c.cl.Bucket(c.bucketName).Object(c.uploadPath + object).NewWriter(ctx)
//         // if _, err := io.Copy(wc, buff); err != nil {
//         //         fmt.Printf("Error:Failed to Upload File io.Copy: %s", err.Error())
//         //         return fmt.Errorf("io.Copy: %v", err)
//         // }
//         // if err := wc.Close(); err != nil {
//         //         fmt.Printf("Error:Failed to Upload File wc.Close: %s", err.Error())
//         //         return fmt.Errorf("Writer.Close: %v", err)
//         // }

//         return nil
// }
</pre>
		
		<pre class="file" id="file36" style="display: none">package ticketHandlers

import (
        "context"
        "fmt"
        "net/http"

        "github.com/guatom999/TicketShop-Movie/modules/ticket"
        "github.com/guatom999/TicketShop-Movie/modules/ticket/ticketUseCases"
        "github.com/labstack/echo/v4"
)

type (
        TicketHandlerService interface {
                AddCustomerTicket(c echo.Context) error
                FindCustomerTicket(c echo.Context) error
                HealthCheck(c echo.Context) error
        }

        ticketHandler struct {
                ticketUseCase ticketUseCases.TicketUseCaseService
        }
)

func NewTicketHandler(ticketUseCase ticketUseCases.TicketUseCaseService) TicketHandlerService <span class="cov0" title="0">{
        return &amp;ticketHandler{ticketUseCase: ticketUseCase}
}</span>

func (h *ticketHandler) HealthCheck(c echo.Context) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, "status ok")
}</span>

func (h *ticketHandler) AddCustomerTicket(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        req := new(ticket.AddTikcetReq)

        if err := c.Bind(req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, "bad req")
        }</span>

        <span class="cov0" title="0">result, err := h.ticketUseCase.AddCustomerTicket(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, fmt.Sprintf("add ticket success %s", result.Hex()))</span>
}

func (h *ticketHandler) FindCustomerTicket(c echo.Context) error <span class="cov0" title="0">{

        ctx := context.Background()

        customerId := c.Param("customer_id")

        result, err := h.ticketUseCase.FindCustomerTicket(ctx, customerId)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadGateway, err.Error())
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package ticketRepositories

import (
        "context"
        "errors"
        "log"
        "time"

        "github.com/guatom999/TicketShop-Movie/modules/ticket"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type (
        TicketRepositoryService interface {
                AddTicket(pctx context.Context, req *ticket.Ticket) (primitive.ObjectID, error)
                FindTicket(pctx context.Context, customerId string) ([]*ticket.TicketShowCase, error)
        }

        ticketRepository struct {
                db *mongo.Client
        }
)

func NewTicketRepository(db *mongo.Client) TicketRepositoryService <span class="cov0" title="0">{
        return &amp;ticketRepository{
                db: db,
        }
}</span>

func (r *ticketRepository) AddTicket(pctx context.Context, req *ticket.Ticket) (primitive.ObjectID, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("ticket_db")
        col := db.Collection("customer_ticket")

        result, err := col.InsertOne(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Add Ticket Failed: %v", err)
                return primitive.NilObjectID, errors.New("error: add tikcet failed")
        }</span>

        <span class="cov0" title="0">log.Println("insert object id is", result.InsertedID.(primitive.ObjectID))

        return result.InsertedID.(primitive.ObjectID), nil</span>
}

func (r *ticketRepository) FindTicket(pctx context.Context, customerId string) ([]*ticket.TicketShowCase, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        db := r.db.Database("ticket_db")
        col := db.Collection("customer_ticket")

        cur, err := col.Find(ctx, bson.M{"customer_id": customerId})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: FindTicket Failed %s", err.Error())
                return make([]*ticket.TicketShowCase, 0), errors.New("error: find ticket failed")
        }</span>

        <span class="cov0" title="0">tickets := make([]*ticket.TicketShowCase, 0)

        for cur.Next(ctx) </span><span class="cov0" title="0">{
                result := new(ticket.Ticket)
                if err := cur.Decode(result); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error: Failed to Decoed Ticket %s", err.Error())
                        return make([]*ticket.TicketShowCase, 0), err
                }</span>

                <span class="cov0" title="0">tickets = append(tickets, &amp;ticket.TicketShowCase{
                        Title: result.MovieName,
                        Seat:  result.Seat,
                        Date:  result.Date,
                        Time:  result.Time,
                        Price: result.Price,
                })</span>
        }

        <span class="cov0" title="0">return tickets, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package ticketUseCases

import (
        "context"

        "github.com/guatom999/TicketShop-Movie/modules/ticket"
        "github.com/guatom999/TicketShop-Movie/modules/ticket/ticketRepositories"
        "github.com/guatom999/TicketShop-Movie/utils"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

type (
        TicketUseCaseService interface {
                AddCustomerTicket(pctx context.Context, req *ticket.AddTikcetReq) (primitive.ObjectID, error)
                FindCustomerTicket(pctx context.Context, customerId string) ([]*ticket.TicketShowCase, error)
        }

        ticketUseCase struct {
                ticketRepo ticketRepositories.TicketRepositoryService
        }
)

func NewTicketUseCase(ticketRepo ticketRepositories.TicketRepositoryService) TicketUseCaseService <span class="cov0" title="0">{
        return &amp;ticketUseCase{
                ticketRepo: ticketRepo,
        }
}</span>

func (u *ticketUseCase) AddCustomerTicket(pctx context.Context, req *ticket.AddTikcetReq) (primitive.ObjectID, error) <span class="cov0" title="0">{

        result, err := u.ticketRepo.AddTicket(pctx, &amp;ticket.Ticket{
                MovieId:    req.MovieId,
                CustomerId: req.CustomerId,
                MovieName:  req.MovieName,
                Seat:       req.Seat,
                Date:       req.Date,
                Time:       req.Time,
                Price:      req.Price,
                CreatedAt:  utils.GetLocaltime(),
                UpdatedAt:  utils.GetLocaltime(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return primitive.NilObjectID, nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>

}

func (u *ticketUseCase) FindCustomerTicket(pctx context.Context, customerId string) ([]*ticket.TicketShowCase, error) <span class="cov0" title="0">{

        tickets, err := u.ticketRepo.FindTicket(pctx, customerId)

        if err != nil </span><span class="cov0" title="0">{
                return tickets, err
        }</span>

        <span class="cov0" title="0">return tickets, nil</span>

}
</pre>
		
		<pre class="file" id="file39" style="display: none">package gcpfile

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "time"

        "cloud.google.com/go/storage"
        "github.com/guatom999/TicketShop-Movie/config"
)

type (
        ClientUpLoader struct {
                cl         *storage.Client
                projectID  string
                bucketName string
                uploadPath string
        }

        FileReq struct {
                File        *multipart.FileHeader `form:"file"`
                Destination string                `form:"destination"`
                Extension   string                `form:"extension"`
                FileName    string                `form:"filename"`
        }

        FileRes struct {
                FileName string `json:"filename"`
                Url      string `json:"url"`
        }
)

func UploadFile(cfg *config.Config, client *storage.Client, pctx context.Context, destination string, data []byte) (string, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(pctx, time.Second*50)
        defer cancel()

        buff := bytes.NewBuffer(data)

        wc := client.Bucket(cfg.Gcp.BucketName).Object(destination).NewWriter(ctx)
        if _, err := io.Copy(wc, buff); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error:Failed to Upload File io.Copy: %s", err.Error())
                return "", errors.New("faile to used io.copy")
        }</span>
        <span class="cov0" title="0">if err := wc.Close(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error:Failed to Upload File wc.Close: %s", err.Error())
                return "", errors.New("faile to closed writer:")
        }</span>

        <span class="cov0" title="0">if err := makePublic(cfg, ctx, client, destination); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error:Faile to Make File Public: %s", err.Error())
                return "", errors.New("error: failed to make file public")
        }</span>

        <span class="cov0" title="0">urlFile := fmt.Sprintf("https://storage.googleapis.com/%s/%s", cfg.Gcp.BucketName, destination)
        // urlFile := fmt.Sprint("https://img-cdn.pixlr.com/image-generator/history/65bb506dcb310754719cf81f/ede935de-1138-4f66-8ed7-44bd16efc709/medium.webp")

        // urlFile = "https://img-cdn.pixlr.com/image-generator/history/65bb506dcb310754719cf81f/ede935de-1138-4f66-8ed7-44bd16efc709/medium.webp"

        return urlFile, nil</span>

}

func makePublic(cfg *config.Config, ctx context.Context, client *storage.Client, destination string) error <span class="cov0" title="0">{

        acl := client.Bucket(cfg.Gcp.BucketName).Object(destination).ACL()
        if err := acl.Set(ctx, storage.AllUsers, storage.RoleReader); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ACLHandle.Set: %w", err)
        }</span>
        // fmt.Printf("Blob %v is now publicly accessible.\n", destination)
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package jwtauth

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "github.com/guatom999/TicketShop-Movie/utils"
)

type (
        AuthInterface interface {
                SignToken() string
        }
        Claims struct {
                CustomerId string `json:"customer_id"`
        }

        CustomerClaims struct {
                *Claims
                jwt.RegisteredClaims
        }

        authConcrete struct {
                Secret []byte
                Claims *CustomerClaims
        }

        accessToken struct {
                *authConcrete
        }

        refreshToken struct {
                *authConcrete
        }
)

func (a *authConcrete) SignToken() string <span class="cov0" title="0">{

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, a.Claims)

        tokenString, _ := token.SignedString(a.Claims)

        return tokenString
}</span>

func ParseToken(secret string, tokenString string) (*CustomerClaims, error) <span class="cov0" title="0">{

        token, err := jwt.ParseWithClaims(tokenString, &amp;CustomerClaims{}, func(token *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("error: unexpected signing method")
                }</span>

                <span class="cov0" title="0">return []byte(secret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, jwt.ErrTokenMalformed) </span><span class="cov0" title="0">{
                        return nil, errors.New("error: token format is invalid")
                }</span> else<span class="cov0" title="0"> if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov0" title="0">{
                        return nil, errors.New("error: token is expired")
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New("error: token is invalid")
                }</span>
        }

        <span class="cov0" title="0">if claims, ok := token.Claims.(*CustomerClaims); ok </span><span class="cov0" title="0">{
                return claims, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, errors.New("error: claims type is invalid")

        }</span>

}

func NewAccessToken(secret string, expireAt int64, claims *Claims) AuthInterface <span class="cov0" title="0">{
        return &amp;accessToken{
                authConcrete: &amp;authConcrete{
                        Secret: []byte(secret),
                        Claims: &amp;CustomerClaims{
                                Claims: claims,
                                RegisteredClaims: jwt.RegisteredClaims{
                                        Issuer:    "seeyarnmirttown.com",
                                        Subject:   "access-token",
                                        Audience:  []string{"seeyarnmirttown.com"},
                                        ExpiresAt: jwt.NewNumericDate(utils.GetLocaltime().Add(time.Second * 20)),
                                        NotBefore: jwt.NewNumericDate(utils.GetLocaltime()),
                                        IssuedAt:  jwt.NewNumericDate(utils.GetLocaltime()),
                                },
                        },
                },
        }
}</span>

func NewRefreshToken(secret string, expireAt int64, claims *Claims) AuthInterface <span class="cov0" title="0">{
        return &amp;refreshToken{
                authConcrete: &amp;authConcrete{
                        Secret: []byte(secret),
                        Claims: &amp;CustomerClaims{
                                Claims: claims,
                                RegisteredClaims: jwt.RegisteredClaims{
                                        Issuer:    "seeyarnmirttown.com",
                                        Subject:   "access-token",
                                        Audience:  []string{"seeyarnmirttown.com"},
                                        ExpiresAt: jwt.NewNumericDate(utils.GetLocaltime().Add(time.Second * 20)),
                                        NotBefore: jwt.NewNumericDate(utils.GetLocaltime()),
                                        IssuedAt:  jwt.NewNumericDate(utils.GetLocaltime()),
                                },
                        },
                },
        }
}</span>

func ReloadToken(secret string, expireAt int64, claims *Claims) AuthInterface <span class="cov0" title="0">{
        return &amp;refreshToken{
                authConcrete: &amp;authConcrete{
                        Secret: []byte(secret),
                        Claims: &amp;CustomerClaims{
                                Claims: claims,
                                RegisteredClaims: jwt.RegisteredClaims{
                                        Issuer:    "seeyarnmirttown.com",
                                        Subject:   "access-token",
                                        Audience:  []string{"seeyarnmirttown.com"},
                                        ExpiresAt: jwt.NewNumericDate(utils.GetLocaltime().Add(time.Second * 20)),
                                        NotBefore: jwt.NewNumericDate(utils.GetLocaltime()),
                                        IssuedAt:  jwt.NewNumericDate(utils.GetLocaltime()),
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package opn

import (
        "log"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/omise/omise-go"
)

func OmiseConn(cfg *config.Config) *omise.Client <span class="cov0" title="0">{

        conn, err := omise.NewClient(cfg.Omise.PublicKey, cfg.Omise.SecretKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect omise")
                panic(err)</span>
        }

        <span class="cov0" title="0">return conn</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package queue

import (
        "context"
        "crypto/tls"
        "fmt"
        "log"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/segmentio/kafka-go"
        "github.com/segmentio/kafka-go/sasl/plain"
)

func KafkaConn(cfg *config.Config, topic string) *kafka.Conn <span class="cov0" title="0">{

        dialer := &amp;kafka.Dialer{
                Timeout: 10 * time.Second,
                TLS:     &amp;tls.Config{}, // Enable TLS
                SASLMechanism: plain.Mechanism{
                        Username: cfg.Kafka.ApiKey,
                        Password: cfg.Kafka.SecretKey,
                },
        }

        conn, err := dialer.DialLeader(context.Background(), "tcp", cfg.Kafka.Url, topic, 0)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov0" title="0">return conn</span>

}

func PushMessageToQueue(cfg *config.Config, key, topic string, message ...kafka.Message) <span class="cov0" title="0">{
        dialer := &amp;kafka.Dialer{
                Timeout: 10 * time.Second,
                TLS:     &amp;tls.Config{}, // Enable TLS
                SASLMechanism: plain.Mechanism{
                        Username: cfg.Kafka.ApiKey,
                        Password: cfg.Kafka.SecretKey,
                },
        }

        conn, err := dialer.DialLeader(context.Background(), "tcp", cfg.Kafka.Url, topic, 0)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov0" title="0">defer conn.Close()

        conn.SetReadDeadline(time.Now().Add(10 * time.Second))

        for _, msg := range message </span><span class="cov0" title="0">{
                msg.Key = []byte(key)
                if _, err := conn.WriteMessages(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing message: %s", err.Error())
                }</span>
        }

}

func KafkaReader(cfg *config.Config, topic, groupID string) *kafka.Reader <span class="cov0" title="0">{
        dialer := &amp;kafka.Dialer{
                Timeout: 10 * time.Second,
                TLS:     &amp;tls.Config{}, // Enable TLS
                SASLMechanism: plain.Mechanism{
                        Username: cfg.Kafka.ApiKey,
                        Password: cfg.Kafka.SecretKey,
                },
        }

        readerConfig := kafka.ReaderConfig{
                Brokers:     []string{cfg.Kafka.Url},
                GroupID:     groupID,
                Topic:       topic,
                StartOffset: kafka.LastOffset,
                Dialer:      dialer,
        }

        reader := kafka.NewReader(readerConfig)

        fmt.Println("Starting consumer...")

        return reader
}</span>

// func ReadMessages(conn *kafka.Conn, key string) {
//         for {

//                 msg, err := conn.ReadMessage(10e6) // 10e6 is the maximum size of the message to read
//                 if err != nil {
//                         fmt.Println("Error reading message:", err)
//                         break
//                 }

//                 if string(msg.Key) == key {
//                         fmt.Printf("Received message: key=%s, value=%s\n", string(msg.Key), string(msg.Value))
//                 }
//         }
// }

// func ReadMessages(reader *kafka.Reader, Key string) {
//         for {
//                 msg, err := reader.ReadMessage(context.Background())
//                 if err != nil {
//                         fmt.Println("Error reading message:", err)
//                         break
//                 }

//                 if string(msg.Key) == Key {
//                         fmt.Printf("Received message: key=%s, value=%s\n", string(msg.Key), string(msg.Value))
//                         // Process the message
//                 } else {
//                         fmt.Printf("Skipping message with key=%s\n", string(msg.Key))
//                 }
//         }
// }

// func IsTopicIsAlreadyExits(conn *kafka.Conn, topic string) bool {
//         partition, err := conn.ReadPartitions()
//         if err != nil {
//                 panic(err.Error())
//         }

//         for _, p := range partition {
//                 if p.Topic == topic {
//                         return true
//                 }
//         }

//         return false
// }
</pre>
		
		<pre class="file" id="file43" style="display: none">package rest

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "net/http"
        "time"
)

func Request(url string) (string, error) <span class="cov0" title="0">{

        client := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        resp, err := client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending GET request: %s", err.Error())
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading response body: %s", err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">return string(body), nil</span>
}

func ReqWithParams(url, params string) (any, error) <span class="cov0" title="0">{

        url = fmt.Sprintf(url, params)

        client := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        resp, err := client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending GET request: %s", err.Error())
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading response body: %s", err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">return string(body), nil</span>
}

func ReqWithBody(url string, body map[string]string) error <span class="cov0" title="0">{
        // Define the URL and body
        bodyData, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error : Failed to Marshall body :%s", err.Error())
                return err
        }</span>

        // Create a new request with method GET and the body
        <span class="cov0" title="0">req, err := http.NewRequest("GET", url, bytes.NewBuffer([]byte(bodyData)))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating request: %s", err.Error())
                return err
        }</span>

        // Create an HTTP client and send the request
        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending request: %s", err.Error())
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read and print the response body
        respBody, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading response: %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Response Status:", resp.Status)
        fmt.Println("Response Body:", string(respBody))

        return nil</span>

}

func Post(url string, value any) error <span class="cov0" title="0">{

        // Define the URL
        // Define the body with access token and other data
        accessToken := "your-access-token"
        requestBody := fmt.Sprintf(`{"accessToken": "%s", "key": "value"}`, value)

        // Convert the body to a byte buffer
        body := bytes.NewBuffer([]byte(requestBody))

        // Create a new POST request
        req, err := http.NewRequest("POST", url, body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating request: %s", err.Error())
                return nil
        }</span>

        // Add headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+accessToken)

        // Create an HTTP client and send the request
        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending request: %s", err.Error())
                return nil
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read and print the response
        respBody, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading response: %s", err.Error())
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Println("Response Status:", resp.Status)
        fmt.Println("Response Body:", string(respBody))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/book/bookHandlers"
        "github.com/guatom999/TicketShop-Movie/modules/book/bookRepositories"
        "github.com/guatom999/TicketShop-Movie/modules/book/bookUseCases"
        "github.com/labstack/echo/v4"
        "github.com/segmentio/kafka-go"
)

func (s *server) BookingModule() <span class="cov0" title="0">{
        bookingRepo := bookRepositories.NewBookRepository()
        bookingUseCase := bookUseCases.NewBookUsecase(bookingRepo)
        bookingHandler := bookHandlers.NewBookHandler(bookingUseCase)

        _ = bookingHandler

        go bookingConsumer(s.cfg)

        bookingRouter := s.app.Group("/booking")

        bookingRouter.GET("/test", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, "Test Success")
        }</span>)

}

func bookingConsumer(cfg *config.Config) <span class="cov0" title="0">{

        // conn := queue.KafkaConn(cfg)

        // offset, _ := conn

        reader := kafka.NewReader(kafka.ReaderConfig{
                Brokers:   []string{cfg.Kafka.Url},
                Topic:     "kafkaapikey",
                Partition: 0,
                MaxBytes:  10e6, // 10MB
        })

        // conn

        fmt.Println("Reader is ", reader.SetOffset(6))

        for </span><span class="cov0" title="0">{
                message, err := reader.ReadMessage(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">fmt.Println("Message is", string(message.Value))</span>
        }

        // if err := conn.Close(); err != nil {
        //         log.Fatal("failed to close connection:", err)
        // }

}
</pre>
		
		<pre class="file" id="file45" style="display: none">package server

import (
        "github.com/guatom999/TicketShop-Movie/modules/customer/customerHandlers"
        "github.com/guatom999/TicketShop-Movie/modules/customer/customerRepositories"
        "github.com/guatom999/TicketShop-Movie/modules/customer/customerUseCases"
        "github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareHandlers"
)

func (s *server) CustomerModules(
        authMiddleware middlewareHandlers.MiddlewareHandlerInterface,
) <span class="cov0" title="0">{
        customerRepo := customerRepositories.NewCustomerRepository(s.db, s.cfg)
        customerUseCase := customerUseCases.NewCustomerUseCase(customerRepo, s.cfg, s.mailer)
        customerHandler := customerHandlers.NewCustomerHandler(customerUseCase, s.cfg)

        customerRouter := s.app.Group("/user")

        // customerRouter.GET("/test-token" , )
        customerRouter.GET("/health", customerHandler.HealthCheck)

        customerRouter.GET("/testjwt", customerHandler.TestJwtAuthorize, authMiddleware.JwtAuthorize)
        // customerRouter.GET("/testjwt", customerHandler.TestJwtAuthorize, m.JwtAuthorize)
        // customerRouter.GET("/testjwt", customerHandler.TestJwtAuthorize)
        customerRouter.POST("/find-access-token", customerHandler.FindAccessToken)
        customerRouter.POST("/login", customerHandler.Login)
        customerRouter.POST("/logout", customerHandler.Logout)
        customerRouter.POST("/refresh-token", customerHandler.RefreshToken)
        customerRouter.POST("/register", customerHandler.Register)

        customerRouter.POST("/forgotpassword", customerHandler.ForgotPassword)

}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package server

import (
        "context"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/guatom999/TicketShop-Movie/config"
        "github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareHandlers"
        "github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareRepositories"
        "github.com/guatom999/TicketShop-Movie/modules/middlewares/middlewareUseCases"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
        "github.com/omise/omise-go"
        "github.com/redis/go-redis/v9"
        "go.mongodb.org/mongo-driver/mongo"
        "gopkg.in/gomail.v2"
)

type (
        Server interface {
                Start(pctx context.Context)
        }

        server struct {
                app    *echo.Echo
                db     *mongo.Client
                cfg    *config.Config
                omise  *omise.Client
                redis  *redis.Client
                mailer *gomail.Dialer
                // middleware middlewareHandlers.MiddlewareHandlerInterface
        }
)

func NewMiddleware(cfg *config.Config) middlewareHandlers.MiddlewareHandlerInterface <span class="cov0" title="0">{
        middlwareRepository := middlewareRepositories.NewMiddlewareRepository()
        middlewareUseCase := middlewareUseCases.NewMiddlwareUseCase(middlwareRepository, cfg)
        middlewareHandlers := middlewareHandlers.NewMiddlewareHandler(middlewareUseCase)

        return middlewareHandlers

}</span>

func NewEchoServer(
        db *mongo.Client,
        cfg *config.Config,
        omise *omise.Client,
        redis *redis.Client,
        mailer *gomail.Dialer,
) Server <span class="cov0" title="0">{
        return &amp;server{
                app:    echo.New(),
                db:     db,
                cfg:    cfg,
                omise:  omise,
                redis:  redis,
                mailer: mailer,
        }
}</span>

func (s *server) gracefulShutdown(pctx context.Context, close &lt;-chan os.Signal) <span class="cov0" title="0">{

        &lt;-close

        ctx, cancel := context.WithTimeout(pctx, time.Second*20)
        defer cancel()

        if err := s.app.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to shutdown server...")
                panic(err)</span>
        }

        <span class="cov0" title="0">log.Println("Shutting Down Server......")</span>

}

func (s *server) Start(pctx context.Context) <span class="cov0" title="0">{
        authMiddleware := NewMiddleware(s.cfg)

        // s = &amp;server{
        //         middleware: authMiddleware,
        // }

        // Request Timeout
        s.app.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
                Skipper:      middleware.DefaultSkipper,
                ErrorMessage: "Error: Request Timeout",
                Timeout:      time.Second * 10,
        }))

        //Cors
        s.app.Use(middleware.CORSWithConfig(middleware.CORSConfig{
                Skipper:      middleware.DefaultSkipper,
                AllowOrigins: []string{"*"},
                AllowMethods: []string{echo.GET, echo.POST, echo.PUT, echo.DELETE, echo.PATCH},
        }))

        s.app.Use(middleware.Logger())

        close := make(chan os.Signal, 1)
        signal.Notify(close, syscall.SIGINT, syscall.SIGTERM)

        go s.gracefulShutdown(pctx, close)

        log.Println("Starting server...")

        switch s.cfg.App.Name </span>{
        case "movie":<span class="cov0" title="0">
                s.MovieModule()</span>
        case "booking":<span class="cov0" title="0">
                s.BookingModule()</span>
        case "ticket":<span class="cov0" title="0">
                s.TicketModule()</span>
        case "inventory":<span class="cov0" title="0">
                s.InventoryModule()</span>
        case "payment":<span class="cov0" title="0">
                s.PaymentModule()</span>
        case "customer":<span class="cov0" title="0">
                s.CustomerModules(authMiddleware)</span>
        }

        <span class="cov0" title="0">if err := s.app.Start(s.cfg.App.Port); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                log.Fatalf("Failed to shutdown:%v", err)

        }</span>

}
</pre>
		
		<pre class="file" id="file47" style="display: none">package server

import (
        "github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryHandlers"
        "github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryRepositories"
        "github.com/guatom999/TicketShop-Movie/modules/inventory/inventoryUseCases"
)

func (s *server) InventoryModule() <span class="cov0" title="0">{
        inventoryRepo := inventoryRepositories.NewInventoryRepository(s.db)
        inventoryUseCase := inventoryUseCases.NewInventoryUseCase(inventoryRepo)
        inventoryHandler := inventoryHandlers.NewInventoryHandler(inventoryUseCase)
        inventoryQueueHandler := inventoryHandlers.NewInventoryQueueHandler(s.cfg, inventoryUseCase)

        ticketRouter := s.app.Group("/inventory")

        ticketRouter.GET("/health", inventoryHandler.HealthCheck)

        go inventoryQueueHandler.AddCustomerTransaction()

        // tikcetRouter.POST("/add", inventoryHandler.FindCustomerTicket)
        ticketRouter.GET("/:customerid", inventoryHandler.GetCustomerTicket)
        ticketRouter.GET("/getlastticket/:customerid", inventoryHandler.FindLastCustomerTicket)
        // ticketRouter.PO

}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package server

import (
        "github.com/guatom999/TicketShop-Movie/modules/movie/moviesHandlers"
        "github.com/guatom999/TicketShop-Movie/modules/movie/moviesRepositories"
        "github.com/guatom999/TicketShop-Movie/modules/movie/moviesUseCases"
)

func (s *server) MovieModule() <span class="cov0" title="0">{
        movieRepo := moviesRepositories.NewMoviesrepository(s.db, s.redis)
        movieUseCase := moviesUseCases.NewmoviesUseCase(s.cfg, movieRepo)
        movieHandler := moviesHandlers.NewMoviesHandler(movieUseCase)
        movieQueueHandler := moviesHandlers.NewMoviesQueueHandler(s.cfg, movieUseCase)

        go movieQueueHandler.ReserveSeat()
        go movieQueueHandler.RollBackSeat()

        movieRouter := s.app.Group("/movie")

        movieRouter.GET("/health", movieHandler.HealthCheck)

        movieRouter.POST("/addmovie", movieHandler.AddOneMovie)
        movieRouter.GET("/getallmovie", movieHandler.GetAllMovie)
        movieRouter.GET("/comingsoonmovie", movieHandler.GetAllComingSoonMovie)
        movieRouter.GET("/getmovie/:movie_id", movieHandler.FindOneMovie)
        movieRouter.GET("/getmovieshowtime/:movieid", movieHandler.FindMovieShowTime)

        movieRouter.POST("/reserveseat", movieHandler.ReserveSeat)

        movieRouter.GET("/test", movieHandler.TestReq)

}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package server

import (
        paymentHandler "github.com/guatom999/TicketShop-Movie/modules/payment/paymentHandlers"
        "github.com/guatom999/TicketShop-Movie/modules/payment/paymentRepositories"
        "github.com/guatom999/TicketShop-Movie/modules/payment/paymentUseCases"
)

func (s *server) PaymentModule() <span class="cov0" title="0">{

        // client, err := storage.NewClient(context.Background())
        // if err != nil {
        //         log.Fatalf("Failed to create client: %v", err)
        // }

        paymentRepo := paymentRepositories.NewPaymentRepository(s.db)
        // paymentUseCase := paymentUseCases.NewPaymentUseCase(paymentRepo, s.cfg, s.omise, client)
        paymentUseCase := paymentUseCases.NewPaymentUseCase(paymentRepo, s.cfg, s.omise)
        paymentHandler := paymentHandler.NewPaymentHanlder(s.cfg, paymentUseCase)

        // ctx := context.Background()

        // resCh := make(chan *payment.RollBackReserveSeatRes)

        // go paymentUseCase.BuyTicketConsumer(ctx, "rollback", resCh)

        // _ = paymentHandler

        router := s.app.Group("/payment")

        router.GET("/health", paymentHandler.HealthCheck)
        router.POST("/buyticket", paymentHandler.BuyTicket)
        router.POST("/testupload", paymentHandler.TestUpload)
        // router.POST("/checkoutwithcreditcard", paymentHandler.CheckOutWithCreditCard)

}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package server

import (
        "github.com/guatom999/TicketShop-Movie/modules/ticket/ticketHandlers"
        "github.com/guatom999/TicketShop-Movie/modules/ticket/ticketRepositories"
        "github.com/guatom999/TicketShop-Movie/modules/ticket/ticketUseCases"
)

func (s *server) TicketModule() <span class="cov0" title="0">{
        ticketRepo := ticketRepositories.NewTicketRepository(s.db)
        ticketUseCase := ticketUseCases.NewTicketUseCase(ticketRepo)
        ticketHandler := ticketHandlers.NewTicketHandler(ticketUseCase)

        ticketRouter := s.app.Group("/ticket")

        ticketRouter.POST("/add", ticketHandler.AddCustomerTicket)

        ticketRouter.GET("/health", ticketHandler.HealthCheck)

        ticketRouter.GET("/:customer_id", ticketHandler.FindCustomerTicket)

}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package test

import "github.com/guatom999/TicketShop-Movie/config"

func TestGetConfig() *config.Config <span class="cov8" title="1">{
        cfg := config.GetConfig("../env/dev/.env.movie")
        return &amp;cfg
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package test

import (
        "testing"

        "github.com/stretchr/testify/assert"
)

func TestHealthCheck(t *testing.T) <span class="cov0" title="0">{
        t.Run("should return success", func(t *testing.T) </span><span class="cov0" title="0">{
                assert.True(t, true)
        }</span>)
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package utils

import (
        "encoding/json"
        "log"

        "go.mongodb.org/mongo-driver/bson/primitive"
)

func ConvertStringToObjectId(id string) primitive.ObjectID <span class="cov0" title="0">{
        objectId, _ := primitive.ObjectIDFromHex(id)
        return objectId
}</span>

func ConvertObjectIdToString(id primitive.ObjectID) string <span class="cov0" title="0">{
        objectString := id.Hex()

        return objectString
}</span>

func EncodeMessage(obj any) []byte <span class="cov0" title="0">{

        raw, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Marshal Failed %s", err.Error())
                return nil
        }</span>

        <span class="cov0" title="0">return raw</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package utils

import (
        "fmt"
        "time"

        "github.com/google/uuid"
)

func RandFileName() string <span class="cov0" title="0">{
        fileName := fmt.Sprintf("%s_%v", uuid.NewString()[:6], time.Now().UnixMilli())

        return fileName
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package utils

import (
        "fmt"
        "strconv"

        "github.com/sigurn/crc16"
)

func GenQRCode(price int) string <span class="cov0" title="0">{

        price = price / 100
        PrompPayKey := crc16.Params{0x1021, 0xFFFF, false, false, 0x0000, 0x0000, "CRC-16/XMODEM"}
        table := crc16.MakeTable(PrompPayKey)

        lenPrice := len(strconv.Itoa(price)) + 3
        priceQrString := fmt.Sprintf("%s.00", strconv.Itoa(price))

        result := fmt.Sprintf("00020101021129370016A000000677010111011300668887874005802TH5303764540%v%v", lenPrice, priceQrString)

        lastFoutDig := crc16.Checksum([]byte(fmt.Sprintf("%v6304", result)), table)

        return fmt.Sprintf("%v6304%X", result, lastFoutDig)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package utils

import (
        "crypto/rand"
        "encoding/hex"
)

func RandomString() string <span class="cov0" title="0">{

        byteString := make([]byte, 4)

        _, err := rand.Read(byteString)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">randomString := hex.EncodeToString(byteString)

        return randomString[:7]</span>

}
</pre>
		
		<pre class="file" id="file57" style="display: none">package utils

import (
        "crypto/tls"
        "errors"
        "fmt"
        "log"
        "net/smtp"
        "strconv"

        "github.com/guatom999/TicketShop-Movie/config"
        "gopkg.in/gomail.v2"
)

type Mailer struct {
}

func SendEmail(cfg *config.Config, to string, subject string, body string) error <span class="cov0" title="0">{
        from := cfg.Mailer.MailerUserName
        password := cfg.Mailer.MailerPassword

        smtpHost := cfg.Mailer.MailerHost
        smtpPort := cfg.Mailer.MailerPort

        message := []byte(fmt.Sprintf("Subject: %s\r\n\r\n%s", subject, body))

        auth := smtp.PlainAuth("", from, password, smtpHost)

        err := smtp.SendMail(smtpHost+":"+strconv.Itoa(smtpPort), auth, from, []string{to}, message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send email: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func SecondSendEmail(cfg *config.Config, message *gomail.Message) error <span class="cov0" title="0">{

        mailer := ConnectToMailer(cfg)

        message.SetHeader("From", "bossbadz642@gmail.com")

        if err := mailer.DialAndSend(message); err != nil </span><span class="cov0" title="0">{
                log.Panicln("[Mailer] ", err)
                return errors.New("failed to send email")
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func ConnectToMailer(cfg *config.Config) *gomail.Dialer <span class="cov0" title="0">{
        mailer := gomail.NewDialer(cfg.Mailer.MailerHost, cfg.Mailer.MailerPort, cfg.Mailer.MailerUserName, cfg.Mailer.MailerPassword)

        mailer.TLSConfig = &amp;tls.Config{InsecureSkipVerify: true}

        return mailer

}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package utils

import (
        "log"
        "time"
)

func GetLocaltime() time.Time <span class="cov0" title="0">{
        loc, err := time.LoadLocation("Asia/Bangkok")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: Load Localtime Failed")
                panic(err)</span>
        }
        <span class="cov0" title="0">return time.Now().In(loc)</span>
}

func ConvertStringDateToTime(stringDate string) time.Time <span class="cov0" title="0">{

        layout := "02-01-2006"

        t, err := time.Parse(layout, stringDate)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing string: %s", err.Error())
                return time.Now()
        }</span>

        <span class="cov0" title="0">return t</span>
}

func SetSpecificTime(year int, month time.Month, day, hour, minute, second int) time.Time <span class="cov0" title="0">{

        specificTime := time.Date(year, month, day, hour, minute, second, 0, time.UTC)
        // log.Println("Specific Time is:", specificTime)

        return specificTime

}</span>

func GetStringTime(showTime time.Time) string <span class="cov0" title="0">{

        formattedTime := showTime.Format("2006-01-02:15:04")

        return formattedTime
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
